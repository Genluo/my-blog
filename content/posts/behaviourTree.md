+++
date = '2025-07-17T16:15:49+08:00'
draft = true
title = 'BehaviourTree'
tags = ['3D', '设计模式']
+++

## 什么是行为树

行为树（Behaviour Tree）是一种用于描述和控制智能体行为的树形数据结构，广泛应用于游戏AI、机器人控制和自动化系统中。

### 核心概念

行为树通过树形结构来组织和执行各种行为，每个节点代表一个特定的行为或控制逻辑：

- **叶子节点（Leaf Nodes）**：执行具体的动作或条件检查
- **复合节点（Composite Nodes）**：控制子节点的执行顺序和逻辑
- **装饰节点（Decorator Nodes）**：修改子节点的行为

### 主要节点类型

#### 1. 动作节点（Action Nodes）

执行具体的行为，如移动、攻击、播放动画等。

#### 2. 条件节点（Condition Nodes）

检查特定条件，返回成功或失败状态。

#### 3. 选择节点（Selector/Fallback）

从左到右执行子节点，直到有一个成功为止。

#### 4. 序列节点（Sequence）

从左到右依次执行所有子节点，全部成功才算成功。

#### 5. 并行节点（Parallel）

同时执行多个子节点。

## 行为树的优势

1. **模块化**：每个节点职责单一，易于复用
2. **可视化**：树形结构直观易懂
3. **灵活性**：可以轻松组合复杂行为
4. **可扩展**：容易添加新的节点类型

## 实际应用场景

### 游戏AI

```text
敌人AI行为树示例：
- Selector
  ├── Sequence（攻击序列）
  │   ├── Condition（玩家在攻击范围内？）
  │   └── Action（执行攻击）
  ├── Sequence（追击序列）
  │   ├── Condition（发现玩家？）
  │   └── Action（向玩家移动）
  └── Action（巡逻）
```

### 机器人控制

行为树可以控制机器人的复杂行为，如导航、避障、任务执行等。

## 和状态机对比

行为树和有限状态机（FSM）都是AI行为控制的常用方法，但它们在设计理念和应用场景上有显著差异：

### 结构差异

#### 状态机（FSM）

- **线性结构**：状态之间通过转换条件连接
- **状态驱动**：基于当前状态决定行为
- **转换复杂**：状态增多时，转换关系呈指数级增长

```text
状态机示例：
[巡逻] --发现敌人--> [追击] --失去目标--> [搜索] --超时--> [巡逻]
   ↑                      ↓
   ←------敌人死亡--------[攻击]
```

#### 行为树（BT）

- **树形结构**：层次化的节点组织
- **行为驱动**：基于条件选择行为
- **模块化**：节点可以独立设计和复用

```text
行为树示例：
Selector
├── Sequence（战斗）
│   ├── Condition（敌人在范围内？）
│   └── Action（攻击）
├── Sequence（追击）
│   ├── Condition（发现敌人？）
│   └── Action（移动到敌人）
└── Action（巡逻）
```

### 复杂度管理

| 特性 | 状态机 | 行为树 |
|------|--------|--------|
| **状态数量** | 随复杂度线性增长 | 通过层次结构管理 |
| **转换关系** | N×N 复杂度 | 树形结构，复杂度可控 |
| **维护难度** | 状态多时难以维护 | 模块化，易于维护 |
| **可读性** | 状态少时直观 | 始终保持良好可读性 |

### 执行方式

#### 状态机

- **持续执行**：进入状态后持续执行该状态的行为
- **显式转换**：需要明确定义所有状态转换条件
- **状态记忆**：天然记住当前状态

#### 行为树

- **每帧评估**：每帧从根节点重新开始评估
- **隐式选择**：通过条件节点自动选择合适行为
- **无状态**：基础版本不保存状态信息

### 适用场景

#### 状态机更适合

- **简单行为**：状态数量较少（<10个）
- **明确状态**：行为有清晰的状态划分
- **状态持续**：需要在状态中停留较长时间
- **性能要求高**：避免每帧重新计算

```text
例子：角色动画控制
[待机] → [行走] → [跑步] → [跳跃] → [落地] → [待机]
```

#### 行为树更适合

- **复杂决策**：需要多层次的行为选择
- **动态响应**：需要快速响应环境变化
- **行为组合**：需要灵活组合不同行为
- **团队开发**：多人协作开发AI系统

```text
例子：RTS游戏单位AI
- 需要同时考虑：攻击、防御、资源采集、建造、逃跑等多种行为
- 优先级动态变化
- 行为可以被中断和重新选择
```

### 混合使用

在实际项目中，两者经常结合使用：

```text
混合方案：
- 高层决策：使用行为树选择主要行为模式
- 低层执行：使用状态机控制具体动作序列

例如：
行为树选择"攻击行为" → 状态机执行"瞄准→射击→装弹"序列
```

### 性能对比

| 方面 | 状态机 | 行为树 |
|------|--------|--------|
| **CPU开销** | 低（只检查转换条件） | 中等（每帧遍历树） |
| **内存使用** | 低（只存储当前状态） | 中等（存储树结构） |
| **扩展性** | 差（状态爆炸） | 好（模块化设计） |
| **调试难度** | 中等 | 容易（可视化树结构） |

### 选择建议

1. **项目初期**：如果行为简单，从状态机开始
2. **需求复杂化**：当状态机变得难以管理时，考虑迁移到行为树
3. **团队规模**：大团队更适合行为树的模块化开发
4. **性能敏感**：移动平台或大量AI实体时，优先考虑状态机
