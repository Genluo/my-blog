[{"content":"Agent 内容 整个 Agent 相关技术拆为两个大的部分进行介绍，一个是对应的工作流，一个是对应的 Agent 开发相关技术\n工作流介绍 顺序执行型：ReAct、Plan \u0026amp; Execute、流水式、提示链 协作优化型：自协商、评估优化、多智能体协作、分层规划 动态编排型：动态编排、自演化、混合模式、路由、并行化、协调者-工作者 顺序执行型 1. ReAct 通过推理（Reasoning）和行动（Acting）交替循环的方式，让Agent在思考和执行工具之间迭代，直到完成任务。\nstateDiagram-v2 [*] --\u0026gt; 接收任务 接收任务 --\u0026gt; 推理思考 推理思考 --\u0026gt; 判断是否需要行动 判断是否需要行动 --\u0026gt; 执行工具: 需要行动 判断是否需要行动 --\u0026gt; 生成答案: 无需行动 执行工具 --\u0026gt; 观察结果 观察结果 --\u0026gt; 推理思考 生成答案 --\u0026gt; [*] 2. Plan \u0026amp; Execute 先制定完整的执行计划，然后按照计划逐步执行各个步骤，适合复杂任务的分解与执行。\nstateDiagram-v2 [*] --\u0026gt; 接收任务 接收任务 --\u0026gt; 规划阶段 规划阶段 --\u0026gt; 生成执行计划 生成执行计划 --\u0026gt; 执行步骤1 执行步骤1 --\u0026gt; 执行步骤2 执行步骤2 --\u0026gt; 执行步骤N 执行步骤N --\u0026gt; 检查完成状态 检查完成状态 --\u0026gt; 返回结果: 已完成 检查完成状态 --\u0026gt; 重新规划: 需调整 重新规划 --\u0026gt; 生成执行计划 返回结果 --\u0026gt; [*] 3. 流水式 将任务按固定顺序分配到多个专门的Agent，每个Agent处理特定环节后传递给下一个，形成处理流水线。\nstateDiagram-v2 [*] --\u0026gt; Agent1 Agent1 --\u0026gt; Agent2: 输出1 Agent2 --\u0026gt; Agent3: 输出2 Agent3 --\u0026gt; Agent4: 输出3 Agent4 --\u0026gt; 最终输出 最终输出 --\u0026gt; [*] 4. 提示链 通过将复杂任务拆解为一系列简单的提示步骤，每步的输出作为下一步的输入，形成提示链式传递。\nstateDiagram-v2 [*] --\u0026gt; Prompt1 Prompt1 --\u0026gt; 生成中间结果1 生成中间结果1 --\u0026gt; Prompt2 Prompt2 --\u0026gt; 生成中间结果2 生成中间结果2 --\u0026gt; Prompt3 Prompt3 --\u0026gt; 生成中间结果3 生成中间结果3 --\u0026gt; PromptN PromptN --\u0026gt; 最终结果 最终结果 --\u0026gt; [*] 协作优化型 1. 自协商 Agent通过自我对话或多角色辩论的方式，从不同视角审视问题，通过协商达成更优的解决方案。\nstateDiagram-v2 [*] --\u0026gt; 接收任务 接收任务 --\u0026gt; 生成初始方案 生成初始方案 --\u0026gt; 角色A提出观点 角色A提出观点 --\u0026gt; 角色B反驳质疑 角色B反驳质疑 --\u0026gt; 角色A回应改进 角色A回应改进 --\u0026gt; 评估是否达成共识 评估是否达成共识 --\u0026gt; 角色B反驳质疑: 未达成 评估是否达成共识 --\u0026gt; 输出协商结果: 已达成 输出协商结果 --\u0026gt; [*] 2. 评估优化 通过独立的评估者Agent对执行结果进行评分和反馈，执行者根据反馈持续优化，直到达到质量标准。\nstateDiagram-v2 [*] --\u0026gt; 执行者生成初始输出 执行者生成初始输出 --\u0026gt; 评估者评分 评估者评分 --\u0026gt; 评估者提供改进建议 评估者提供改进建议 --\u0026gt; 判断质量 判断质量 --\u0026gt; 执行者优化改进: 未达标 判断质量 --\u0026gt; 输出最终结果: 已达标 执行者优化改进 --\u0026gt; 评估者评分 输出最终结果 --\u0026gt; [*] 3. 多智能体协作 多个具有不同专长的 Agent 协同工作，通过信息共享和任务分配，发挥各自优势完成复杂任务。\nstateDiagram-v2 [*] --\u0026gt; 任务分配器 任务分配器 --\u0026gt; Agent1专家 任务分配器 --\u0026gt; Agent2专家 任务分配器 --\u0026gt; Agent3专家 Agent1专家 --\u0026gt; 共享信息池 Agent2专家 --\u0026gt; 共享信息池 Agent3专家 --\u0026gt; 共享信息池 共享信息池 --\u0026gt; 协调者 协调者 --\u0026gt; 判断是否完成 判断是否完成 --\u0026gt; 分配后续任务: 未完成 判断是否完成 --\u0026gt; 结果汇总: 已完成 分配后续任务 --\u0026gt; Agent1专家 分配后续任务 --\u0026gt; Agent2专家 分配后续任务 --\u0026gt; Agent3专家 结果汇总 --\u0026gt; [*] 4. 分层规划 采用层次化的规划策略，高层Agent负责宏观规划和目标分解，低层Agent负责具体执行，实现复杂任务的结构化管理。\nstateDiagram-v2 [*] --\u0026gt; 高层规划Agent 高层规划Agent --\u0026gt; 制定战略目标 制定战略目标 --\u0026gt; 分解为子目标 分解为子目标 --\u0026gt; 中层规划Agent 中层规划Agent --\u0026gt; 制定执行计划 制定执行计划 --\u0026gt; 分配具体任务 分配具体任务 --\u0026gt; 低层执行Agent 低层执行Agent --\u0026gt; 执行具体操作 执行具体操作 --\u0026gt; 向上反馈结果 向上反馈结果 --\u0026gt; 中层规划Agent 中层规划Agent --\u0026gt; 评估进度 评估进度 --\u0026gt; 高层规划Agent: 汇报总体进展 高层规划Agent --\u0026gt; 判断目标完成 判断目标完成 --\u0026gt; 调整战略: 需调整 判断目标完成 --\u0026gt; 输出最终结果: 已完成 调整战略 --\u0026gt; 分解为子目标 输出最终结果 --\u0026gt; [*] 动态编排型 1. 动态编排 根据任务执行过程中的实时状态和反馈，动态调整工作流程和 Agent 组合，实现灵活的任务编排。\nstateDiagram-v2 [*] --\u0026gt; 接收任务 接收任务 --\u0026gt; 分析任务特征 分析任务特征 --\u0026gt; 动态生成工作流 动态生成工作流 --\u0026gt; 执行当前步骤 执行当前步骤 --\u0026gt; 评估执行状态 评估执行状态 --\u0026gt; 判断是否需要调整 判断是否需要调整 --\u0026gt; 重新编排工作流: 需要调整 判断是否需要调整 --\u0026gt; 继续执行: 无需调整 重新编排工作流 --\u0026gt; 执行当前步骤 继续执行 --\u0026gt; 判断任务完成 判断任务完成 --\u0026gt; 执行当前步骤: 未完成 判断任务完成 --\u0026gt; 输出结果: 已完成 输出结果 --\u0026gt; [*] 2. 自演化 Agent 通过学习历史经验和反馈，不断优化自身的提示词、工具选择和决策策略，实现自我进化。\nstateDiagram-v2 [*] --\u0026gt; 初始化Agent 初始化Agent --\u0026gt; 执行任务 执行任务 --\u0026gt; 收集执行数据 收集执行数据 --\u0026gt; 分析成功失败案例 分析成功失败案例 --\u0026gt; 提取经验模式 提取经验模式 --\u0026gt; 更新策略库 更新策略库 --\u0026gt; 优化提示词 优化提示词 --\u0026gt; 调整工具选择 调整工具选择 --\u0026gt; 升级Agent版本 升级Agent版本 --\u0026gt; 验证新版本 验证新版本 --\u0026gt; 执行任务: 持续进化 验证新版本 --\u0026gt; 回滚版本: 效果变差 回滚版本 --\u0026gt; 执行任务 3. 混合模式 结合多种工作流模式的优势，针对不同子任务采用最适合的执行模式，形成混合工作流架构。\nstateDiagram-v2 [*] --\u0026gt; 任务分析 任务分析 --\u0026gt; 子任务1 任务分析 --\u0026gt; 子任务2 任务分析 --\u0026gt; 子任务3 子任务1 --\u0026gt; ReAct模式 子任务2 --\u0026gt; 流水式模式 子任务3 --\u0026gt; 多智能体协作模式 ReAct模式 --\u0026gt; 结果汇总 流水式模式 --\u0026gt; 结果汇总 多智能体协作模式 --\u0026gt; 结果汇总 结果汇总 --\u0026gt; 整合输出 整合输出 --\u0026gt; [*] 4. 路由 根据任务类型、复杂度或领域特征，智能路由到最适合的 Agent 或处理流程，实现任务的精准分发。\nstateDiagram-v2 [*] --\u0026gt; 接收任务 接收任务 --\u0026gt; 路由分析器 路由分析器 --\u0026gt; 判断任务类型 判断任务类型 --\u0026gt; 简单查询Agent: 简单查询 判断任务类型 --\u0026gt; 复杂推理Agent: 复杂推理 判断任务类型 --\u0026gt; 代码生成Agent: 代码任务 判断任务类型 --\u0026gt; 数据分析Agent: 数据分析 简单查询Agent --\u0026gt; 返回结果 复杂推理Agent --\u0026gt; 返回结果 代码生成Agent --\u0026gt; 返回结果 数据分析Agent --\u0026gt; 返回结果 返回结果 --\u0026gt; [*] 5. 并行化 将独立的子任务或步骤并行分配给多个 Agent 同时执行，显著提升整体执行效率。\nstateDiagram-v2 [*] --\u0026gt; 任务分解 任务分解 --\u0026gt; 并行执行 state 并行执行 { [*] --\u0026gt; Agent1 [*] --\u0026gt; Agent2 [*] --\u0026gt; Agent3 [*] --\u0026gt; Agent4 Agent1 --\u0026gt; [*] Agent2 --\u0026gt; [*] Agent3 --\u0026gt; [*] Agent4 --\u0026gt; [*] } 并行执行 --\u0026gt; 等待所有任务完成 等待所有任务完成 --\u0026gt; 结果聚合 结果聚合 --\u0026gt; 最终输出 最终输出 --\u0026gt; [*] 6. 协调者-工作者 协调者 Agent 负责任务分配、进度监控和结果整合，工作者 Agent 专注于执行具体任务，实现职责分离。\nstateDiagram-v2 [*] --\u0026gt; 协调者接收任务 协调者接收任务 --\u0026gt; 协调者分析任务 协调者分析任务 --\u0026gt; 协调者分配任务 协调者分配任务 --\u0026gt; 工作者1执行 协调者分配任务 --\u0026gt; 工作者2执行 协调者分配任务 --\u0026gt; 工作者3执行 工作者1执行 --\u0026gt; 工作者1报告进度 工作者2执行 --\u0026gt; 工作者2报告进度 工作者3执行 --\u0026gt; 工作者3报告进度 工作者1报告进度 --\u0026gt; 协调者监控 工作者2报告进度 --\u0026gt; 协调者监控 工作者3报告进度 --\u0026gt; 协调者监控 协调者监控 --\u0026gt; 判断完成状态 判断完成状态 --\u0026gt; 协调者调整策略: 需要调整 判断完成状态 --\u0026gt; 协调者整合结果: 全部完成 协调者调整策略 --\u0026gt; 协调者分配任务 协调者整合结果 --\u0026gt; 输出最终结果 输出最终结果 --\u0026gt; [*] Agent 相关技术 上下文 问题 1. 上下文中毒 指错误信息、幻觉内容或过时数据被写入 Agent 的上下文后，被模型反复引用、强化，最终导致整个推理链条崩坏的现象。一旦错误信息进入上下文，模型会将其视为可信事实，在后续推理中不断基于这些错误前提进行演绎，形成错误累积和放大效应。\n解决思路：建立信息源可信度评估机制，对外部输入进行验证；引入事实核查层，对关键信息进行交叉验证；使用时间戳标记上下文信息的时效性，定期更新过时数据；实施上下文质量监控，检测推理链中的逻辑矛盾；采用多路径验证策略，通过不同推理路径交叉印证结果的正确性。\n2. 上下文干扰 指上下文中存在过多无关或冗余信息，干扰模型对关键信息的识别和处理。在长对话或复杂任务中，早期的无关细节可能分散模型注意力，降低对当前任务重点的把握能力。\n解决思路：采用上下文压缩技术提取关键信息摘要；实施滑动窗口机制只保留最近的相关对话；使用相关性评分算法筛选高价值信息；引入注意力引导提示词明确指向当前任务重点；定期进行上下文清理，移除过时或无关内容。\n3. 上下文混淆 指多个任务或对话线程的信息在上下文中交织，导致模型无法正确区分和关联相关信息。当处理多轮嵌套对话或并行任务时，模型可能混淆不同场景的参数、状态或目标。在 MCP（Model Context Protocol）场景中，当可用工具数量过多时，模型难以准确匹配工具功能与任务需求，容易选错工具或混淆相似工具的使用场景。\n解决思路：为不同任务或对话线程分配独立的上下文空间；使用明确的标识符或分隔标记区分不同场景；采用命名空间机制隔离不同任务的状态和变量；建立上下文索引系统快速定位相关信息；在提示词中显式声明当前操作的任务范围；对于 MCP 工具管理，采用分层分类组织工具，根据任务类型动态加载相关工具子集，使用语义化的工具描述和示例增强工具识别度。\n4. 上下文飘移 指随着交互轮次增加，上下文逐渐偏离原始任务目标或主题的现象。模型可能在长对话中逐步丢失初始意图，转向相关但非核心的话题，导致最终输出与用户预期不符。\n解决思路：在上下文中持久化保留原始任务目标作为锚点；定期回顾和重申初始意图；设置偏离度检测机制，当话题偏离超过阈值时触发提醒；使用目标导向的提示词模板引导对话回归主线；建立任务完成度评估体系，确保每个交互步骤与最终目标的关联性。\n技术 1. 上下文压缩 上下文压缩是应对长文本处理和上下文窗口限制的关键技术，主要包括三种方式：\n过滤式压缩（删除）：通过相关性评分、关键词匹配或语义相似度计算，筛选出与当前任务最相关的信息片段，过滤掉冗余或低价值内容，保留核心上下文，适用于需要快速降低上下文长度的场景，优势在于实现简单、效率高，但可能丢失潜在有用的边缘信息。\n提炼式压缩（浓缩）：利用摘要模型或大语言模型对原始上下文进行语义提炼，将长文本浓缩为简洁的摘要或关键点列表，保留核心语义和逻辑关系，适用于需要保持信息完整性和连贯性的场景，能够在大幅压缩的同时保持语义质量，但依赖模型的理解和生成能力，可能引入摘要偏差。\n结构化压缩：将非结构化的上下文信息转换为结构化表示，如知识图谱、表格、JSON对象或向量嵌入，通过结构化组织实现信息的高效存储和检索，适用于需要频繁查询和复用上下文的场景，优势在于支持精确检索和关系推理，但需要额外的结构化处理步骤，对信息的结构化质量要求较高。\n2. 上下文卸载 上下文卸载是将暂时不需要的上下文信息从活跃工作区转移到外部存储的技术，以释放有限的上下文窗口空间，主要包括以下几种方式：\n基于时间的卸载（LRU策略）：采用最近最少使用（Least Recently Used）算法，根据上下文信息的访问时间戳，优先卸载最久未被访问的内容，这种方式假设最近使用的信息更可能在近期再次被需要，实现简单且适用于大多数场景，但可能误卸载重要但暂时未访问的关键信息，适合处理时序性强的对话和任务。\n基于优先级的卸载：为上下文中的不同信息片段分配优先级权重，如任务目标、用户明确指令、关键决策节点等赋予高优先级，而中间推理过程、临时计算结果等赋予低优先级，当上下文空间不足时优先卸载低优先级内容，这种方式能够保护核心信息不被误删，但需要建立合理的优先级评估机制，适用于复杂任务和长期对话场景。\n基于语义相关性的卸载：通过计算上下文片段与当前任务的语义相似度或相关性评分，卸载与当前任务关联度低的历史信息，利用向量嵌入和语义检索技术动态评估信息价值，这种方式能够智能识别真正无关的内容，但计算开销较大且依赖语义理解质量，适合需要精确保留相关上下文的知识密集型任务。\n分层卸载策略：将上下文信息按照抽象层次分为不同级别，如原始对话记录、中间推理步骤、提炼后的结论和元信息等，优先卸载低层次的原始数据，保留高层次的精炼信息和摘要，这种方式在节省空间的同时保持信息的可追溯性，支持必要时从外部存储重新加载详细内容，适用于需要平衡详细度和效率的长期运行Agent。\n触发式卸载：设置上下文使用率的阈值监控机制，当上下文占用率达到预设警戒线（如80%）时自动触发卸载流程，或在任务阶段切换、对话主题转移等关键节点主动进行上下文清理，这种方式结合了被动响应和主动管理，能够在保证性能的同时避免上下文溢出，适合动态变化的交互场景和多任务并行处理。\n3. 上下文存储 上下文存储是将卸载的上下文信息持久化保存并支持高效检索的技术，确保历史信息在需要时能够快速恢复到工作区，主要包括以下几种方式：\n向量数据库存储：将上下文信息通过嵌入模型转换为高维向量表示，存储在专门的向量数据库（如Pinecone、Milvus、Weaviate）中，支持基于语义相似度的快速检索，这种方式能够实现\u0026quot;模糊匹配\u0026quot;式的上下文召回，根据当前任务需求检索语义相关的历史信息，适合需要智能联想和知识关联的场景，但向量化过程可能损失部分细节信息，且对嵌入模型质量依赖较高。\n关系数据库存储：采用传统关系型数据库（如PostgreSQL、MySQL）存储结构化的上下文信息，通过表结构组织对话轮次、任务ID、时间戳、角色等元数据，支持精确的SQL查询和复杂的关联检索，这种方式适合需要严格事务保证和复杂查询逻辑的场景，能够高效处理结构化数据和关系推理，但对非结构化文本的语义检索能力有限，通常需要结合全文索引或向量检索增强。\n文档数据库存储：使用文档型NoSQL数据库（如MongoDB、Elasticsearch）存储JSON格式的上下文文档，保留原始对话结构和嵌套关系，支持灵活的schema设计和全文检索，这种方式在保持数据完整性的同时提供较好的查询灵活性，适合半结构化数据和快速迭代的场景，Elasticsearch还提供强大的全文搜索和聚合分析能力，但在复杂关系查询上不如关系数据库。\n分层混合存储：根据上下文信息的访问频率和重要性采用分层存储策略，热数据（近期高频访问）保存在内存缓存（如Redis）中实现毫秒级访问，温数据（中期偶尔访问）存储在高速SSD数据库中，冷数据（长期归档）转移到对象存储（如S3）或归档系统中，这种方式平衡了访问性能和存储成本，通过自动数据迁移机制实现生命周期管理，适合大规模长期运行的Agent系统。\n图数据库存储：利用图数据库（如Neo4j、ArangoDB）将上下文信息建模为知识图谱，节点表示实体或概念，边表示关系或依赖，支持复杂的图遍历和关系推理查询，这种方式特别适合需要理解上下文间复杂关联关系的场景，如多轮对话中的指代消解、因果关系追踪、知识推理等，能够通过图算法发现隐含的信息关联，但图数据建模和维护成本较高。\n混合索引存储：结合多种索引技术构建混合检索系统，如同时使用向量索引（语义检索）、倒排索引（关键词检索）、时间索引（时序查询）和元数据索引（属性过滤），根据查询需求动态选择最优检索路径或融合多路检索结果，这种方式能够应对多样化的上下文召回需求，提供更全面和精确的检索能力，适合复杂的企业级Agent应用，但系统复杂度和维护成本相对较高。\n管理 1. 黑板模型 黑板模型（Blackboard Model）是一种经典的知识共享和协作架构，源于人工智能早期的专家系统研究，现在被广泛应用于多Agent系统的上下文管理中。其核心思想是模拟多个专家围绕一块\u0026quot;黑板\u0026quot;协作解决问题的场景：黑板作为共享的工作空间存储当前问题状态和中间结果，多个独立的知识源（Knowledge Sources）通过读取和更新黑板来协同工作，控制器负责协调各知识源的激活顺序。\n核心组件：\n黑板（Blackboard）：中央共享数据结构，存储问题求解过程中的所有信息，包括初始输入、中间推理结果、候选方案和最终解决方案。黑板通常采用分层结构组织信息，如原始数据层、特征提取层、假设层、决策层等，支持不同抽象级别的信息表示和访问。\n知识源（Knowledge Sources, KS）：独立的专家模块，每个知识源负责特定领域或特定类型的推理任务，如数据解析、模式识别、约束检查、方案生成等。知识源之间相互独立，不直接通信，只通过读写黑板进行间接协作。每个知识源包含触发条件（Condition）和执行动作（Action），当黑板状态满足其触发条件时被激活执行。\n控制器（Controller）：协调和调度机制，监控黑板状态变化，评估各知识源的触发条件，决定下一步激活哪个知识源，管理执行优先级和冲突解决。控制策略可以是规则驱动、优先级驱动、机会主义驱动或基于元知识的智能调度。\n工作流程：\nstateDiagram-v2 [*] --\u0026gt; 初始化黑板 初始化黑板 --\u0026gt; 控制器监控 控制器监控 --\u0026gt; 评估知识源触发条件 评估知识源触发条件 --\u0026gt; 选择待激活知识源 选择待激活知识源 --\u0026gt; 知识源读取黑板 知识源读取黑板 --\u0026gt; 知识源执行推理 知识源执行推理 --\u0026gt; 知识源更新黑板 知识源更新黑板 --\u0026gt; 检查问题是否解决 检查问题是否解决 --\u0026gt; 控制器监控: 未解决 检查问题是否解决 --\u0026gt; 输出最终结果: 已解决 输出最终结果 --\u0026gt; [*] 在Agent上下文管理中的应用：\n多Agent协作的信息共享：黑板作为多个Agent之间的共享工作空间，每个Agent可以将自己的推理结果、发现的信息、生成的假设写入黑板，同时读取其他Agent贡献的内容，实现去中心化的信息交换，避免点对点通信的复杂性。\n异构知识的整合：不同Agent可能使用不同的推理方式（符号推理、神经网络、规则引擎等）和知识表示（文本、结构化数据、向量等），黑板提供统一的接口和数据格式，使异构Agent能够无缝协作。\n增量式问题求解：复杂任务的解决过程是渐进式的，黑板记录每一步的进展和中间状态，支持Agent从部分解逐步构建完整解，允许回溯和修正，适应动态变化的问题环境。\n机会主义推理：不需要预定义严格的执行顺序，控制器根据当前黑板状态和各Agent的能力动态决定下一步行动，哪个Agent有能力推进当前状态就激活哪个，实现灵活的任务编排。\n上下文分层管理：黑板的分层结构天然支持上下文的抽象层次管理，底层存储原始数据和详细信息，高层存储提炼后的知识和决策，Agent可以根据需要访问不同层次的上下文，实现精细化的上下文控制。\n优势：\n松耦合：知识源之间独立，易于添加、删除或替换Agent，系统扩展性强 透明性：所有信息集中在黑板上，便于监控、调试和解释推理过程 灵活性：支持动态调度和机会主义推理，适应复杂多变的任务 容错性：单个知识源失败不影响整体系统，其他知识源可以继续工作 挑战：\n并发控制：多个Agent同时读写黑板需要同步机制，避免竞态条件和数据不一致 调度复杂性：设计高效的控制策略需要平衡全局最优和计算开销 黑板膨胀：随着推理深入黑板信息量快速增长，需要结合上下文压缩和卸载技术 死锁风险：不当的触发条件设计可能导致没有知识源被激活或循环等待 现代实现方式：\n在现代Agent系统中，黑板模型常与向量数据库、消息队列、分布式缓存等技术结合实现：\n使用Redis或共享内存作为高性能黑板存储 采用发布-订阅模式实现黑板更新的事件通知 结合向量检索实现基于语义的黑板信息查询 使用版本控制和事务机制保证并发安全 引入优先级队列和智能调度算法优化控制策略 2. 类脑记忆 类脑记忆（Brain-inspired Memory）是借鉴人类大脑记忆机制设计的上下文管理方案，通过模拟人脑的多层次记忆系统、遗忘曲线、记忆巩固等认知过程，实现更加智能和高效的上下文管理。与传统的线性存储或简单缓存不同，类脑记忆强调记忆的动态性、层次性和自适应性，使Agent能够像人类一样选择性地记忆重要信息、遗忘无关细节、在需要时快速回忆相关经验。\n核心机制：\n多层次记忆结构：模拟人脑的感觉记忆、工作记忆（短期记忆）和长期记忆三级体系\n感觉记忆（Sensory Memory）：极短暂的原始输入缓存，保留最近几轮的完整对话或感知数据，容量小但保真度高，类似人脑对刚刚发生事件的即时印象，通常保持数秒到数分钟，用于快速响应和上下文连贯性\n工作记忆（Working Memory）：当前任务的活跃上下文，容量有限但访问速度快，存储正在处理的信息、中间推理步骤、临时变量和即时目标，对应Agent的\u0026quot;注意力焦点\u0026quot;，类似人脑在解决问题时能同时把握的信息量（约7±2个信息块）\n长期记忆（Long-term Memory）：持久化的知识和经验库，容量几乎无限但需要检索激活，分为显性记忆（事实、事件）和隐性记忆（技能、模式），通过编码和巩固过程从工作记忆转入，支持基于相关性和重要性的选择性提取\n记忆编码与巩固：模拟人脑将短期记忆转化为长期记忆的过程\n重要性评估：根据信息的任务相关性、情感强度（用户明确强调）、重复频率、新颖性等维度计算重要性分数，决定是否值得长期保存\n语义编码：将原始信息转换为语义表示（向量嵌入、知识图谱节点），提取关键概念和关系，去除冗余细节，便于后续的语义检索和关联\n巩固机制：通过定期回顾、关联强化、摘要提炼等方式巩固重要记忆，类似人脑在睡眠中的记忆整合过程，可以在Agent空闲时或任务间隙进行后台巩固\n自适应遗忘机制：模拟人脑的遗忘曲线（Ebbinghaus Forgetting Curve）\n时间衰减：记忆强度随时间指数衰减，越久未访问的记忆越容易被遗忘，但重要记忆衰减速度较慢\n主动遗忘：当存储空间不足时，优先遗忘低重要性、低访问频率、与当前任务无关的记忆，避免上下文膨胀\n遗忘保护：对于核心知识、用户明确要求记住的信息、高频访问的记忆设置保护机制，防止误删\n可恢复性：被遗忘的信息不是立即删除，而是降级到冷存储，必要时仍可恢复，类似人脑的\u0026quot;提取失败\u0026quot;而非\u0026quot;完全丢失\u0026quot;\n联想检索与激活扩散：模拟人脑通过联想回忆相关记忆的过程\n语义联想：基于向量相似度或知识图谱关系，从当前上下文触发相关记忆的检索，一个概念可以激活语义相近或有关联的其他记忆\n情景回忆：根据相似的任务场景、问题模式或上下文特征，检索历史中的类似经验，支持案例推理和经验迁移\n激活扩散：被激活的记忆节点会扩散激活相邻节点，形成记忆网络的局部激活区域，类似人脑的\u0026quot;一个想法引发另一个想法\u0026quot;\n记忆重构与更新：模拟人脑记忆的可塑性和重构特性\n动态更新：当新信息与已有记忆冲突时，更新或修正旧记忆，而非简单覆盖，保留版本历史以支持回溯\n记忆融合：将多次相似经验融合为更抽象的模式或规则，提取共性知识，类似人脑的概念形成过程\n重构偏差意识：记录记忆的来源、可信度和修改历史，避免因重构导致的记忆失真被当作原始事实\n工作流程：\nstateDiagram-v2 [*] --\u0026gt; 感觉记忆接收输入 感觉记忆接收输入 --\u0026gt; 工作记忆加载 工作记忆加载 --\u0026gt; 评估重要性 评估重要性 --\u0026gt; 编码为长期记忆: 重要信息 评估重要性 --\u0026gt; 保持在工作记忆: 临时信息 编码为长期记忆 --\u0026gt; 语义索引与关联 语义索引与关联 --\u0026gt; 长期记忆存储 保持在工作记忆 --\u0026gt; 任务处理 任务处理 --\u0026gt; 联想检索长期记忆 联想检索长期记忆 --\u0026gt; 激活相关记忆 激活相关记忆 --\u0026gt; 加载到工作记忆 加载到工作记忆 --\u0026gt; 任务处理 任务处理 --\u0026gt; 工作记忆更新 工作记忆更新 --\u0026gt; 检查容量 检查容量 --\u0026gt; 卸载到长期记忆: 容量不足 检查容量 --\u0026gt; 继续任务: 容量充足 卸载到长期记忆 --\u0026gt; 编码为长期记忆 长期记忆存储 --\u0026gt; 后台巩固 后台巩固 --\u0026gt; 遗忘衰减处理 遗忘衰减处理 --\u0026gt; 清理低价值记忆 清理低价值记忆 --\u0026gt; 长期记忆存储 继续任务 --\u0026gt; 判断任务完成 判断任务完成 --\u0026gt; 感觉记忆接收输入: 未完成 判断任务完成 --\u0026gt; 输出结果: 已完成 输出结果 --\u0026gt; [*] 在Agent上下文管理中的应用：\n智能容量管理：通过多层次结构和自适应遗忘，自动平衡上下文窗口的有限容量与信息完整性需求，无需人工设置复杂的卸载规则\n经验积累与迁移：长期记忆中积累的历史经验可以在新任务中被联想检索，实现跨任务的知识迁移和快速适应\n上下文连贯性：工作记忆保持当前任务的活跃状态，感觉记忆提供即时历史，确保对话和推理的流畅性\n个性化记忆：针对不同用户或任务领域，形成差异化的长期记忆库，实现个性化的上下文管理\n抗干扰能力：通过重要性评估和选择性编码，过滤噪音信息，避免上下文中毒和干扰\n优势：\n自然性：符合人类认知习惯，易于理解和调试 自适应：根据任务特点和信息重要性动态调整记忆策略 高效性：多层次结构优化了访问速度和存储成本的平衡 鲁棒性：遗忘机制防止上下文膨胀，联想检索增强信息利用率 挑战：\n复杂性：实现完整的类脑记忆系统需要多个子模块协同工作 参数调优：遗忘曲线、重要性权重、巩固策略等参数需要针对具体应用场景调优 计算开销：后台巩固、联想检索、激活扩散等过程增加计算负担 评估困难：记忆质量和遗忘合理性难以量化评估 实现技术：\n向量数据库：存储长期记忆的语义表示，支持高效的联想检索（如Pinecone、Milvus） 图数据库：建模记忆间的关联关系，支持激活扩散和关系推理（如Neo4j） 优先级队列：管理工作记忆的容量和信息优先级 时间序列数据库：记录记忆的访问历史和衰减曲线（如InfluxDB） 强化学习：优化重要性评估和遗忘策略的参数 注意力机制：在工作记忆中动态聚焦最相关的信息片段 3. 解耦模块与动态扩展 解耦模块与动态扩展是 L2MAC（Large Language Model Agent with Multi-Agent Collaboration）等先进架构中突破上下文长度限制的核心方法，通过将复杂任务分解为多个独立的子任务模块，每个模块维护自己的局部上下文，避免单一 Agent 的上下文窗口被快速耗尽。这种方法的本质是\u0026quot;分而治之\u0026quot;——将原本需要在一个超长上下文中处理的信息，分散到多个专门化的模块中，通过模块间的协作和信息传递完成整体任务。\n核心思想：\n传统的单体 Agent 在处理复杂任务时，需要将所有相关信息（任务描述、历史对话、工具文档、中间结果等）都塞入一个上下文窗口，很快就会遇到长度限制。L2MAC 通过模块化解耦，将任务处理流程拆分为多个职责明确的模块，每个模块只需要关注自己负责的子任务和相关上下文，大大降低了单个上下文的负担。\nL2MAC 的模块化架构：\nstateDiagram-v2 [*] --\u0026gt; 任务规划模块 任务规划模块 --\u0026gt; 任务分解 任务分解 --\u0026gt; 子任务队列 子任务队列 --\u0026gt; 工具选择模块 工具选择模块 --\u0026gt; 确定所需工具 确定所需工具 --\u0026gt; 执行模块A 确定所需工具 --\u0026gt; 执行模块B 确定所需工具 --\u0026gt; 执行模块C 执行模块A --\u0026gt; 局部上下文A 执行模块B --\u0026gt; 局部上下文B 执行模块C --\u0026gt; 局部上下文C 局部上下文A --\u0026gt; 结果聚合模块 局部上下文B --\u0026gt; 结果聚合模块 局部上下文C --\u0026gt; 结果聚合模块 结果聚合模块 --\u0026gt; 评估是否完成 评估是否完成 --\u0026gt; 子任务队列: 需要继续 评估是否完成 --\u0026gt; 最终输出: 已完成 最终输出 --\u0026gt; [*] 关键技术机制：\n任务分解与模块分配（Task Decomposition and Module Assignment）：\n分层规划：高层规划模块将复杂任务分解为多个相对独立的子任务，每个子任务分配给专门的执行模块，规划模块只需维护任务依赖关系和执行顺序，不需要保留所有细节\n职责隔离：每个执行模块只负责特定类型的子任务（如数据检索、代码生成、结果验证等），只需加载与该子任务相关的上下文和工具，避免无关信息的干扰\n动态加载：根据当前子任务的需求，动态加载相应的工具文档、示例和知识，用完即卸载，而不是一开始就将所有可能用到的信息塞入上下文\n局部上下文管理（Local Context Management）：\n上下文隔离：每个执行模块维护独立的局部上下文，只包含当前子任务的输入、相关知识和执行历史，与其他模块的上下文物理隔离，互不干扰\n按需传递：模块间通过精简的消息传递接口交换信息，只传递必要的结果和状态，而不是完整的上下文历史，例如执行模块 A 完成后只向聚合模块传递结果摘要，而不是整个推理过程\n上下文重置：每个子任务完成后，其执行模块的上下文可以被清空或归档，为下一个子任务释放空间，实现上下文的循环利用\n增量式信息聚合（Incremental Information Aggregation）：\n流式聚合：结果聚合模块不是等所有子任务完成后一次性处理，而是采用流式聚合，每当一个子任务完成就立即整合其结果，保持聚合模块的上下文精简\n摘要提炼：对每个子任务的输出进行摘要提炼，提取关键信息后再加入全局上下文，过滤掉冗余细节，例如将一个 1000 token 的执行日志压缩为 50 token 的结果摘要\n分层存储：将详细的执行过程存储在外部（如向量数据库），全局上下文只保留高层摘要，需要时通过检索召回细节\n工具与知识的按需加载（On-demand Tool and Knowledge Loading）：\n工具分组：将大量工具按功能域分组（如文件操作、网络请求、数据处理等），每个执行模块只加载其需要的工具组，避免工具列表过长导致的上下文膨胀和工具选择混淆\n延迟加载：工具的详细文档和示例不在初始化时加载，而是在确定需要使用某个工具后才加载其详细说明，使用后立即卸载\n知识索引：将领域知识构建为可检索的知识库，执行模块根据子任务需求动态检索相关知识片段，而不是预先加载所有知识\n模块间的轻量通信（Lightweight Inter-Module Communication）：\n消息队列：使用消息队列或事件总线实现模块间的异步通信，发送方只需投递消息，不需要维护接收方的状态，降低耦合度\n标准化接口：定义统一的消息格式和接口协议，模块间交换的数据结构化且精简（如 JSON 格式的任务描述和结果），避免传递冗长的自然语言描述\n状态外部化：共享状态存储在外部状态管理器（如 Redis、数据库）中，模块通过状态 ID 引用，而不是在上下文中复制完整状态\n并行执行与上下文复用（Parallel Execution and Context Reuse）：\n并行模块：对于相互独立的子任务，可以启动多个执行模块并行处理，每个模块使用独立的上下文窗口，突破单一上下文的串行处理限制\n模块池：维护一个执行模块池，相同类型的子任务可以复用同一类模块实例，共享工具加载和初始化开销，但保持上下文隔离\n上下文模板：为常见的子任务类型预定义上下文模板，快速初始化执行模块，减少重复的上下文构建成本\n实际应用示例：\n假设一个复杂任务：\u0026ldquo;分析某公司最近三年的财报，生成投资建议报告\u0026rdquo;\n传统单体 Agent 的问题：\n需要在上下文中加载：任务描述、财报文档（可能很长）、分析工具文档、报告模板、历史对话等 上下文很快被耗尽，无法容纳完整的财报内容 工具选择时面对所有可用工具，容易混淆 L2MAC 的解耦方案：\n规划模块：分解为子任务 → ①获取财报 ②提取关键指标 ③趋势分析 ④生成报告 执行模块 1（财报获取）：局部上下文只包含：公司名称、年份范围、文档检索工具 → 输出：财报文档路径 执行模块 2（指标提取）：局部上下文只包含：财报文档、数据提取工具 → 输出：结构化指标数据（精简） 执行模块 3（趋势分析）：局部上下文只包含：指标数据、分析算法工具 → 输出：分析结论摘要 执行模块 4（报告生成）：局部上下文只包含：分析结论、报告模板、生成工具 → 输出：最终报告 聚合模块：只需维护各阶段的摘要结果，而不是完整的中间过程 优势：\n突破长度限制：每个模块的上下文需求远小于整体任务，可以处理原本无法在单一上下文中完成的复杂任务 提高准确性：模块专注于特定子任务，上下文更聚焦，减少无关信息的干扰，提高工具选择和推理的准确性 并行加速：独立子任务可以并行执行，缩短总体执行时间 可扩展性：新增功能只需添加新的执行模块，不影响现有模块 容错性：单个模块失败不会污染其他模块的上下文，可以独立重试或替换 挑战：\n任务分解质量：分解不当可能导致子任务间依赖复杂，反而增加协调成本 信息损失：模块间传递摘要可能丢失重要细节，需要平衡精简与完整性 协调开销：模块间通信和状态管理引入额外的系统复杂度 调试困难：问题可能出现在任何模块或模块间的交互，需要完善的监控和追踪机制 实现技术：\n多 Agent 框架：如 AutoGen、CrewAI、LangGraph 支持多 Agent 协作和模块化编排 消息队列：如 Celery、RabbitMQ 实现模块间的异步任务分发 状态管理：如 Redis、Memcached 存储共享状态和中间结果 工作流引擎：如 Airflow、Prefect 管理复杂的模块依赖和执行流程 向量数据库：如 Pinecone、Weaviate 存储和检索知识片段 分布式追踪：如 OpenTelemetry、Jaeger 追踪跨模块的执行链路 4. 领域定制化上下文优化 领域定制化上下文优化是针对特定应用领域（如医疗、法律、金融、代码生成等）的上下文管理策略，通过深度理解领域特性和任务模式，设计专门化的上下文组织、压缩和检索方案，相比通用方案能够显著提升上下文利用效率和任务完成质量。\n核心思想：\n不同领域的任务具有独特的信息结构、知识依赖和推理模式，通用的上下文管理方案往往无法充分利用这些领域特性。通过领域定制化，可以：\n识别领域中的关键信息类型和优先级 设计符合领域逻辑的上下文结构 利用领域知识进行智能压缩和扩展 优化领域特定的信息检索和推理路径 领域特性分析：\n医疗领域：\n信息特性：患者病史、检查结果、诊断标准、药物信息等结构化程度高 优先级：最新的检查结果、过敏史、当前用药等关键信息必须保留 推理模式：基于症状→检查→诊断→治疗的流程化推理 定制策略：将患者信息结构化为医疗记录模板，关键字段（过敏、慢性病）设置高优先级永不卸载，历史就诊记录按时间和相关性分层存储 法律领域：\n信息特性：法条、案例、证据材料、法律文书等，引用关系复杂 优先级：适用法条、关键证据、判例先例必须精确保留 推理模式：基于法条解释、案例类比、证据链推理 定制策略：构建法条知识图谱，通过引用关系检索相关法条，案例按相似度索引，证据材料按证明目标分类组织 代码生成领域：\n信息特性：代码库结构、API 文档、依赖关系、代码规范等 优先级：当前编辑文件的上下文、直接依赖的接口定义、相关的代码示例 推理模式：基于代码结构理解、API 调用、设计模式应用 定制策略：通过 AST 分析提取代码结构，按调用关系和模块依赖动态加载相关代码，使用代码摘要（函数签名、类定义）代替完整实现 金融领域：\n信息特性：市场数据、财务报表、交易规则、风险指标等，时效性强 优先级：最新市场数据、监管规则、风险阈值必须实时准确 推理模式：基于数据分析、趋势预测、风险评估 定制策略：时序数据按时间窗口聚合，历史数据存储统计特征而非原始值，规则和阈值参数化存储，通过参数引用而非重复描述 定制化技术方法：\n领域本体与知识图谱：\n构建领域特定的本体模型，定义核心概念、关系和约束 将领域知识组织为知识图谱，支持基于关系的上下文扩展和推理 上下文中只保留概念节点 ID 和关系，详细信息通过图查询按需获取 领域 DSL 与模板：\n设计领域特定语言（DSL）简洁表达领域概念，减少自然语言的冗余 预定义领域任务模板，标准化上下文结构，提高信息密度 例如医疗领域用结构化的 SOAP 笔记（Subjective, Objective, Assessment, Plan）代替自由文本 领域感知的压缩与摘要：\n训练领域特定的摘要模型，理解领域术语和重要性 基于领域知识的智能省略，例如法律文书中省略格式化条款，保留实质内容 利用领域缩写和标准化表达，例如医疗领域的疾病编码（ICD-10）、药物通用名 领域优化的检索策略：\n设计领域特定的检索索引，例如代码领域按符号和调用关系索引，法律领域按法条编号和案由索引 结合领域规则的混合检索，例如金融领域优先检索最新数据，医疗领域优先检索相关症状的诊断指南 利用领域知识进行查询扩展，例如检索\u0026quot;高血压\u0026quot;时自动扩展到相关的\u0026quot;降压药\u0026quot;、\u0026ldquo;心血管疾病\u0026rdquo; 领域特定的上下文分层：\n根据领域任务流程设计上下文层次，例如代码生成分为\u0026quot;项目架构层\u0026quot;、\u0026ldquo;模块接口层\u0026rdquo;、\u0026ldquo;函数实现层\u0026rdquo; 不同层次采用不同的保留策略和压缩比例 支持按层次的上下文切换和聚焦 优势：\n高效性：充分利用领域特性，上下文密度和相关性更高 准确性：符合领域逻辑的上下文组织提升推理质量 专业性：使用领域术语和标准，输出更符合专业要求 可解释性：基于领域知识的推理路径更易于专业人士理解和验证 挑战：\n开发成本：需要领域专家参与设计和验证 通用性损失：过度定制可能降低跨领域的适应能力 维护成本：领域知识和规则需要持续更新 冷启动问题：新领域缺乏足够的领域知识积累 实现技术：\n知识图谱：Neo4j、ArangoDB 存储领域本体和知识关系 领域模型：基于领域语料微调的 LLM 或专门的领域编码器 规则引擎：Drools、Easy Rules 管理领域规则和约束 领域数据库：针对特定领域优化的数据存储（如时序数据库 InfluxDB、医疗数据库 FHIR） 模板引擎：Jinja2、Mustache 管理领域模板和 DSL 多模型 协同方式 多智能体系统中的协同方式决定了 Agent 之间如何分配任务、传递信息和协调行动，主要有三种协同方式：\n1. 自由转交（Free Handoff） 自由转交是一种去中心化的协同方式，Agent 之间可以自主决定何时、向谁转交任务，无需预定义的流程或中央协调者。每个 Agent 根据当前任务状态、自身能力边界和其他 Agent 的专长，动态选择最合适的协作对象进行任务转交。这种方式灵活性最高，适合探索性和复杂多变的任务，但可能面临协调复杂、效率不确定和难以追踪的挑战。\n2. 工作流编排（Workflow Orchestration） 工作流编排是一种预定义、结构化的协同方式，通过事先设计好的工作流程图或规则，明确规定任务的执行顺序、Agent 的职责分工和信息流转路径。通常由一个中央编排器（Orchestrator）负责协调和调度各个 Agent 的执行，确保任务按照既定流程有序推进。这种方式可预测性强、易于管理和监控，适合标准化、重复性的业务流程，但灵活性较差，难以应对动态变化的情况。\n3. Plan \u0026amp; Execute 协同（Plan \u0026amp; Execute Collaboration） Plan \u0026amp; Execute 协同是一种结合了规划智能和执行灵活性的混合方式，先由规划 Agent 制定整体执行计划，然后由执行 Agent 按计划执行，执行过程中根据实际情况动态调整计划。规划 Agent 负责任务分解和宏观决策，执行 Agent 处理具体细节并反馈结果，形成计划-执行-反馈的闭环。这种方式在结构化和灵活性之间取得平衡，适合需要宏观规划和细节执行相结合的复杂多步骤任务，既有整体规划指导又能灵活应对变化。\n协同类型 多智能体系统中的协同类型反映了 Agent 之间的目标关系和互动模式，主要有三种协同类型：\n1. 合作（Cooperation） 合作是指多个 Agent 共享相同或一致的目标，通过明确的分工协作来共同完成任务。每个 Agent 发挥自己的专长负责特定子任务，彼此之间相互配合、信息共享，最终汇总各自的贡献形成完整解决方案。这种类型强调团队协作和优势互补，适合复杂任务的模块化分解，能够充分利用不同 Agent 的专业能力，但需要良好的协调机制来避免重复劳动和信息孤岛。\n2. 竞争（Competition） 竞争是指多个 Agent 针对同一问题独立提出不同的解决方案，通过辩论、评估或博弈的方式相互挑战和质疑，最终选出最优方案或综合各方观点。这种类型利用观点冲突和多样性来发现问题、纠正偏差、提升决策质量，类似于\u0026quot;红队-蓝队\u0026quot;对抗或多角度审视。竞争机制能够有效避免单一视角的盲点和群体思维陷阱，激发创新思维，但可能增加计算成本和决策时间，需要合理的评判标准来裁定优劣。\n3. 竞合（Coopetition） 竞合是合作与竞争的混合模式，Agent 之间在某些环节合作、在某些环节竞争，既有共同目标又存在局部利益冲突。例如多个 Agent 共同收集信息（合作），但各自独立提出解决方案并竞争最终采纳权（竞争），或者在迭代优化过程中交替进行协作改进和对抗验证。这种类型结合了合作的效率和竞争的质量保障，适合需要平衡多样性和一致性的复杂场景，能够在保持团队协同的同时激发个体创造力，但需要精心设计合作与竞争的边界和转换机制。\n通信结构 多智能体系统中的通信结构定义了 Agent 之间信息交换的拓扑关系和消息流转模式，主要有三种通信结构：\n1. 集中式（Centralized） 集中式通信结构采用中心节点（如协调者或编排器）作为信息枢纽，所有 Agent 之间的通信都通过中心节点中转和协调。中心节点负责接收各 Agent 的消息、进行任务分配、协调执行顺序、汇总结果，其他 Agent 不直接相互通信。这种结构管理简单、易于监控和全局优化，适合需要严格控制和集中决策的场景，但中心节点可能成为性能瓶颈和单点故障风险，且扩展性受限于中心节点的处理能力。\n2. 去中心化（Decentralized） 去中心化通信结构中没有固定的中心节点，Agent 之间采用点对点（P2P）的方式直接通信，每个 Agent 可以自主决定与谁交互、何时交互。Agent 之间地位平等，通过自组织和自协调完成任务，信息在网络中以分布式方式传播和处理。这种结构灵活性高、容错性强、无单点故障，适合动态变化和大规模分布式场景，但协调复杂度高，可能出现信息冗余或不一致，全局优化困难，需要设计良好的共识机制和冲突解决策略。\n3. 分层式（Hierarchical） 分层式通信结构将 Agent 组织为多层次的树状或金字塔结构，不同层级承担不同角色和职责。高层 Agent 负责宏观规划、战略决策和跨域协调，中层 Agent 负责任务分解和区域管理，底层 Agent 负责具体执行和数据采集。通信主要发生在相邻层级之间，上层向下层下达指令和目标，下层向上层反馈结果和状态。这种结构兼具集中式的可控性和去中心化的扩展性，适合大规模复杂系统和组织化任务，能够实现职责分离和抽象层次管理，但层级过多可能导致通信延迟和信息失真，需要平衡层次深度和通信效率。\n协同策略 多智能体系统中的协同策略决定了 Agent 如何进行决策和行动选择，主要有三种协同策略：\n1. 基于角色（Role-Based） 基于角色的协同策略为每个 Agent 分配明确的角色定位和职责范围，Agent 根据自己的角色来决定行为模式和交互方式。例如在软件开发团队中，可以设置产品经理、架构师、开发者、测试工程师等不同角色，每个角色有特定的专业知识、权限边界和工作流程。这种策略通过角色分工实现专业化和责任明确，便于管理和协调，适合职责清晰的结构化任务，但角色设计的合理性直接影响系统效能，且角色固化可能降低灵活性。\n2. 基于规则（Rule-Based） 基于规则的协同策略通过预定义的规则集来指导 Agent 的协同行为，规则明确规定在特定条件下应该采取什么行动、与谁协作、如何处理冲突。规则可以是简单的 if-then 条件语句，也可以是复杂的业务逻辑和约束条件。这种策略具有确定性和可解释性，行为可预测且易于审计，适合有明确规范和合规要求的领域（如金融、医疗），但规则的完备性和维护成本是挑战，难以应对规则未覆盖的新情况，且规则冲突时需要优先级机制。\n3. 基于模型（Model-Based） 基于模型的协同策略让 Agent 通过学习和推理来自主决定协同行为，而非依赖固定的角色或规则。Agent 可以使用机器学习模型（如强化学习）从历史经验中学习最优协作策略，或使用大语言模型进行情境理解和动态决策。这种策略具有高度的自适应性和智能性，能够处理复杂多变的场景，发现隐含的协作模式，适合开放性和不确定性高的任务，但模型的训练成本高、决策过程可解释性差，且需要大量数据和计算资源，模型质量直接决定协同效果。\n协同机制 多智能体系统中的协同机制决定了 Agent 协作关系的建立方式和时机，主要有两种协同机制：\n1. 静态协同（Static Collaboration） 静态协同机制在系统设计阶段就预定义好 Agent 之间的协作流程、交互关系和任务分配方案，运行时严格按照既定流程执行。协作图（包括 Agent 角色、连接关系、通信路径、执行顺序等）在启动前已经确定，不会因任务内容或执行状态而改变。这种机制具有高度的稳定性和可预测性，执行效率高且易于测试验证，适合流程固定、需求明确的标准化场景（如生产流水线、审批流程），但缺乏灵活性，难以应对任务变化和异常情况，扩展新功能需要重新设计整个协作流程。\n2. 动态协同（Dynamic Collaboration） 动态协同机制根据任务的具体需求和实时执行状态，在运行时动态创建和调整 Agent 之间的协作图。系统会分析任务特征、评估可用 Agent 的能力，实时决定需要哪些 Agent 参与、如何分工、以什么顺序执行，协作关系可以随着任务进展而演化。这种机制具有高度的灵活性和适应性，能够根据实际情况优化资源配置，适合复杂多变、需求不确定的场景（如应急响应、个性化服务），但动态决策增加了系统复杂度和计算开销，协作图的生成质量依赖于任务理解和 Agent 能力评估的准确性，且运行时的不确定性增加了调试和故障排查的难度。\n记忆系统 MEMGPT https://arxiv.org/abs/2310.08560\nMemGPT（Memory-enhanced GPT）是一个突破性的记忆系统，通过模拟操作系统的虚拟内存管理机制来突破大语言模型的上下文窗口限制。它将记忆分为主内存（main context）和外部存储（external context），通过智能的分页调度算法在有限的上下文窗口中动态加载最相关的记忆片段。MemGPT 引入了类似操作系统的内存管理指令集，Agent 可以显式地调用 core_memory_append、core_memory_replace、archival_memory_insert、archival_memory_search 等函数来管理自己的记忆，实现了对长期对话历史和大规模知识库的高效管理，使 Agent 能够在无限长的对话中保持连贯性和个性化。\nA-MEM https://arxiv.org/abs/2502.12110\nA-MEM（Adaptive Memory）是一种自适应的多层次记忆系统，核心特点是根据信息的访问模式和重要性动态调整记忆的存储层级和保留策略。它采用分层存储架构（热-温-冷三层），结合访问频率、时间衰减和语义相关性等多维度指标，自动将记忆在不同存储层之间迁移。A-MEM 引入了记忆强化机制，被频繁访问或被 Agent 标记为重要的记忆会得到强化，衰减速度变慢并优先保留，而长期未使用的记忆则逐渐降级到冷存储甚至被遗忘。这种自适应机制使 Agent 能够像人类一样选择性地记住重要信息，自动平衡记忆容量和信息完整性。\nMemory OS of AI Agent https://arxiv.org/abs/2506.06326\nMemory OS 是一个为 AI Agent 设计的完整记忆操作系统，提供了统一的记忆管理抽象层和丰富的记忆操作接口。它将记忆管理从 Agent 的核心逻辑中解耦出来，提供类似操作系统的系统调用接口，包括记忆的创建、读取、更新、删除、检索、索引、压缩、归档等全生命周期管理功能。Memory OS 支持多种记忆类型（情景记忆、语义记忆、程序记忆）和存储后端（向量数据库、图数据库、关系数据库），提供统一的查询语言和事务保证，使不同的 Agent 应用能够基于标准化的记忆接口进行开发，大幅降低记忆系统的实现复杂度和提高可移植性。\nM3-Agent https://arxiv.org/pdf/2508.09736\nM3-Agent（Multi-Modal Multi-Memory Agent）是一个支持多模态和多记忆类型的综合记忆系统，特别强调跨模态信息的统一记忆和关联。它能够同时处理和记忆文本、图像、音频、视频等多种模态的信息，通过多模态编码器将不同模态统一映射到共享的语义空间，实现跨模态的记忆检索和推理。M3-Agent 区分了不同类型的记忆（如事实记忆、经验记忆、技能记忆、社交记忆），为每种记忆类型设计专门的存储结构和检索策略，并通过记忆融合机制将多源多模态的记忆片段整合为连贯的知识表示，使 Agent 能够在复杂的多模态交互场景中保持丰富的记忆能力。\nAgent KB https://arxiv.org/pdf/2507.06229\nAgent KB（Agent Knowledge Base）是一个面向 Agent 的知识库系统，专注于结构化知识的组织和高效检索。与传统记忆系统侧重对话历史和经验不同，Agent KB 强调领域知识的系统化管理，采用知识图谱作为核心数据结构，将实体、概念、关系、规则等知识元素组织为可推理的图结构。它提供了知识的增量更新、版本管理、一致性校验、冲突解决等企业级功能，支持基于图遍历的复杂查询和多跳推理，并能够与外部知识源（如维基百科、企业数据库）进行知识同步和融合。Agent KB 使 Agent 能够基于结构化知识进行精确推理和可解释决策，特别适合知识密集型的专业领域应用。\n","permalink":"https://genluo.github.io/my-blog/posts/agent/","summary":"\u003ch2 id=\"agent-内容\"\u003e\u003ccode\u003eAgent\u003c/code\u003e 内容\u003c/h2\u003e\n\u003cp\u003e整个 \u003ccode\u003eAgent\u003c/code\u003e 相关技术拆为两个大的部分进行介绍，一个是对应的工作流，一个是对应的 \u003ccode\u003eAgent\u003c/code\u003e 开发相关技术\u003c/p\u003e\n\u003ch3 id=\"工作流介绍\"\u003e工作流介绍\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e顺序执行型：ReAct、Plan \u0026amp; Execute、流水式、提示链\u003c/li\u003e\n\u003cli\u003e协作优化型：自协商、评估优化、多智能体协作、分层规划\u003c/li\u003e\n\u003cli\u003e动态编排型：动态编排、自演化、混合模式、路由、并行化、协调者-工作者\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"顺序执行型\"\u003e顺序执行型\u003c/h4\u003e\n\u003ch5 id=\"1-react\"\u003e1. ReAct\u003c/h5\u003e\n\u003cp\u003e通过推理（Reasoning）和行动（Acting）交替循环的方式，让Agent在思考和执行工具之间迭代，直到完成任务。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003estateDiagram-v2\n    [*] --\u0026gt; 接收任务\n    接收任务 --\u0026gt; 推理思考\n    推理思考 --\u0026gt; 判断是否需要行动\n    判断是否需要行动 --\u0026gt; 执行工具: 需要行动\n    判断是否需要行动 --\u0026gt; 生成答案: 无需行动\n    执行工具 --\u0026gt; 观察结果\n    观察结果 --\u0026gt; 推理思考\n    生成答案 --\u0026gt; [*]\n\u003c/code\u003e\u003c/pre\u003e\u003ch5 id=\"2-plan--execute\"\u003e2. Plan \u0026amp; Execute\u003c/h5\u003e\n\u003cp\u003e先制定完整的执行计划，然后按照计划逐步执行各个步骤，适合复杂任务的分解与执行。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003estateDiagram-v2\n    [*] --\u0026gt; 接收任务\n    接收任务 --\u0026gt; 规划阶段\n    规划阶段 --\u0026gt; 生成执行计划\n    生成执行计划 --\u0026gt; 执行步骤1\n    执行步骤1 --\u0026gt; 执行步骤2\n    执行步骤2 --\u0026gt; 执行步骤N\n    执行步骤N --\u0026gt; 检查完成状态\n    检查完成状态 --\u0026gt; 返回结果: 已完成\n    检查完成状态 --\u0026gt; 重新规划: 需调整\n    重新规划 --\u0026gt; 生成执行计划\n    返回结果 --\u0026gt; [*]\n\u003c/code\u003e\u003c/pre\u003e\u003ch5 id=\"3-流水式\"\u003e3. 流水式\u003c/h5\u003e\n\u003cp\u003e将任务按固定顺序分配到多个专门的Agent，每个Agent处理特定环节后传递给下一个，形成处理流水线。\u003c/p\u003e","title":"Agent 技术调研"},{"content":"契机 最近因为一些契机看了下互动小游戏的服务端，深入了解了下现在互动游戏服务端的架构，同时也尝试在这个架构的基础上使用 AI 进行一些游戏业务功能开发，其中印象最深的服务端的一个称之为基座的架构设计，这个基座架构深度使用 DDD 领域设计思想进行抽象实现，在游戏业务非常灵活，复用性非常高，所以想看下在NodeJS 中针对 DDD领域驱动设计是否有一定的实践。下面主要分为两个部分，一个是为什么是DDD？另一个 NodeJS中一些实践\nDDD 什么是领域驱动设计（domain driving design） 领域驱动设计是一种软件设计方法，用于表示和组织特定领域中的知识和业务逻辑。它主要通过创建抽象的模型对象来模拟现实世界的实体及其关系，帮助开发人员理解和实现复杂系统的业务逻辑。在领域驱动设计中，通常会包含以下几个关键概念：\n实体（Entity）：具有唯一标识的对象，通常表示业务中的一个独立的概念或对象。例如，在一个订单系统中，订单和客户可以被视为实体。\n值对象（Value Object）：没有唯一标识的对象，通常用于描述某个实体的属性或细节。它们是不可变的，两个值对象如果具有相同的属性值，则认为是相等的。例如，一个地址可以作为一个值对象。\n聚合（Aggregate）：一组相关的对象（实体和值对象）的集合，它们被视为一个单元进行数据修改。聚合有一个根实体（Aggregate Root），通过根实体来管理聚合的生命周期。\n领域服务（Domain Service）：封装领域逻辑的操作，这些操作不属于任何一个实体或值对象。它们通常用于表示跨越多个实体或值对象的业务逻辑。\n仓储（Repository）：提供访问持久化存储中对象的方法，通常用于获取和保存聚合根。\n什么是聚合根 指的是一个聚合中具有唯一标识的核心实体，该实体负责控制整个聚合的生命周期和一致性。\n控制访问：聚合根是聚合内的唯一入口点，外部对象只能通过聚合根来访问或操作聚合中的其它对象。这有助于保持聚合内部的完整性和一致性。\n管理生命周期：聚合根负责管理聚合内所有对象的生命周期，包括创建、更新和删除操作。通过聚合根，可以确保对聚合中数据的任何修改都是合法和一致的。\n一致性边界：聚合定义了一个一致性边界，其中的所有对象在事务中应该保持一致。因此，聚合根通过确保在其范围内的操作都是一致的，来维持这种边界。\n唯一性：每个聚合都有一个唯一的聚合根。通常，聚合根具有唯一标识符，用来标识和访问该聚合。\n持久化管理：通过仓储（Repository）模式，聚合根通常是持久化操作（如保存和检索）的主要对象。这意味着仓储通常只直接处理聚合根，而不是聚合内的其它对象。\n领域驱动设计优缺点 领域驱动设计（Domain-Driven Design, DDD）是一种软件设计方法，旨在通过紧密结合业务需求和技术实现来构建复杂软件系统。以下是领域驱动设计的一些优缺点：\n优点 更好地理解业务：\nDDD强调与领域专家的密切合作，使开发团队对业务需求有更深入的理解。这有助于创建更符合业务需求的系统。 清晰的模型：\n通过使用统一语言和领域模型，所有团队成员（包括技术人员和非技术人员）都可以在同一语境下沟通，从而减少误解。 灵活性和可维护性：\nDDD鼓励模块化设计，如界限上下文（Bounded Context）和聚合（Aggregate），这些设计有助于简化系统的维护和扩展。 关注核心领域：\n通过识别和聚焦于核心领域，DDD帮助团队将资源集中在对业务最重要的部分，从而提高竞争力。 支持复杂系统开发：\nDDD为处理复杂领域逻辑提供了有力的方法和工具，可以有效地管理复杂性。 缺点 学习曲线陡峭：\n对许多开发人员和组织来说，DDD的概念和技术术语可能较为陌生，初始学习和实施成本较高。 时间和资源投入大：\n由于需要深度的领域分析和持续的团队协作，DDD可能比传统方法花费更多时间和资源。 不适合所有项目：\n对于简单或小型项目，DDD可能过于复杂和冗余，投入的成本和收益不成比例。 需求稳定性要求高：\nDDD更适合于需求相对稳定且对业务逻辑要求高的项目。对于需求频繁变化的项目，可能需要经常重构。 对团队协作要求高：\n成功实施DDD需要团队成员之间良好的沟通和协作，这对团队的组织文化和沟通能力提出了较高要求。 为什么需要领域模型 在传统的软件开发中,我们常常遇到以下问题：\n1. 贫血模型的困境 传统的开发方式往往采用\u0026quot;贫血模型\u0026quot;（Anemic Domain Model），即：\n数据对象只包含字段和简单的 getter/setter，没有任何业务逻辑 所有业务逻辑集中在 Service 层，形成庞大的服务类 数据和行为分离，导致代码难以理解和维护 2. 业务逻辑散乱 缺乏统一的业务规则管理：同样的业务逻辑可能在多个地方重复实现 难以保证一致性：订单创建、修改、取消等操作中的业务规则可能不一致 维护成本高：修改一个业务规则需要在多个地方查找和修改 3. 技术与业务脱节 代码难以反映业务意图：开发人员看到的是表、字段、SQL，而不是订单、支付、发货等业务概念 与领域专家沟通困难：技术术语和业务术语无法对应，容易产生理解偏差 需求变更代价大：业务调整时，需要从底层数据结构开始重新设计 领域模型如何解决这些问题 领域模型通过以下方式解决上述问题：\n1. 封装业务逻辑 // 充血模型示例 class Order { constructor(id, userId) { this.id = id; this.userId = userId; this.items = []; this.status = \u0026#39;PENDING\u0026#39;; } // 业务逻辑封装在实体内部 addItem(product, quantity) { if (this.status !== \u0026#39;PENDING\u0026#39;) { throw new Error(\u0026#39;只能向待处理订单添加商品\u0026#39;); } if (quantity \u0026lt;= 0) { throw new Error(\u0026#39;商品数量必须大于0\u0026#39;); } this.items.push({ product, quantity }); } submit() { if (this.items.length === 0) { throw new Error(\u0026#39;订单不能为空\u0026#39;); } this.status = \u0026#39;SUBMITTED\u0026#39;; // 触发领域事件 this.addDomainEvent(new OrderSubmittedEvent(this)); } calculateTotal() { return this.items.reduce((sum, item) =\u0026gt; sum + item.product.price * item.quantity, 0); } } 2. 统一语言（Ubiquitous Language） 代码中的类名、方法名直接对应业务概念 开发人员和领域专家使用相同的术语 代码即文档，业务规则清晰可见 3. 维护业务不变性（Invariants） 通过聚合根控制状态变更 确保对象始终处于有效状态 业务规则在一个地方定义和维护 4. 降低认知负担 每个领域对象职责清晰 业务逻辑内聚，易于理解和测试 修改影响范围可控 实践价值 引入领域模型后，带来的实际价值：\n代码可读性提升：新人可以通过阅读领域模型快速理解业务 维护成本降低：业务规则集中管理，修改影响范围明确 测试更容易：领域对象可以独立测试，不依赖数据库和外部服务 应对复杂度：当业务逻辑变得复杂时，领域模型的优势更加明显 长期价值：随着项目演进，领域模型帮助保持代码质量和架构清晰度 总结：领域模型不是银弹，但对于业务逻辑复杂的系统来说，它提供了一种更加贴近业务、易于维护的代码组织方式。通过将数据和行为结合，领域模型让代码真正成为业务知识的表达\n举例 下面通过一个游戏中的\u0026quot;宠物喂养升级\u0026quot;模型来展示如何使用DDD进行设计\n业务场景 在一个宠物养成游戏中，玩家可以：\n喂养宠物获得经验值 宠物经验值达到一定数量后进行升级 宠物升级后有对应的奖励物 最终根据宠物的奖励物发放对应的奖励 业务流程图 stateDiagram-v2 [*] --\u0026gt; 待喂养: 宠物初始状态 待喂养 --\u0026gt; 增加经验: 玩家喂养食物 增加经验 --\u0026gt; 检查升级条件: 经验值累加 检查升级条件 --\u0026gt; 升级中: 经验值 \u0026gt;= 所需经验 检查升级条件 --\u0026gt; 待喂养: 经验值 \u0026lt; 所需经验 升级中 --\u0026gt; 属性提升: 消耗经验值 属性提升 --\u0026gt; 奖励生成: 等级+1, 属性增加 奖励生成 --\u0026gt; 检查升级条件: 继续检查是否能再次升级 奖励生成 --\u0026gt; 发放奖励: 所有升级完成 发放奖励 --\u0026gt; 待喂养: 奖励发放完毕 note right of 检查升级条件 不同品质宠物 所需经验不同 - 普通: 1.0x - 稀有: 1.2x - 史诗: 1.5x end note note right of 属性提升 属性增长公式 HP: +10 * 品质倍率 Attack: +5 * 品质倍率 end note 状态说明：\n待喂养：宠物的正常状态，等待玩家投喂食物 增加经验：喂养后经验值增加的瞬时状态 检查升级条件：判断当前经验是否足够升级（支持连续升级） 升级中：消耗经验值，进行等级提升 属性提升：根据品质倍率计算新的属性值 奖励生成：基于升级结果生成奖励物品 发放奖励：将奖励物品发放给玩家 传统实现方式 // 数据模型 class Pet { id; name; level; exp; quality; // 品质：普通、稀有、史诗 hp; attack; } // Service层处理所有业务逻辑 class PetService { async feed(petId, foodValue) { // 1. 查询宠物 const pet = await db.query(\u0026#39;SELECT * FROM pets WHERE id = ?\u0026#39;, [petId]); // 2. 计算经验值 pet.exp += foodValue; // 3. 检查是否升级（逻辑分散） let levelUpCount = 0; while (pet.exp \u0026gt;= this.getRequiredExp(pet.level, pet.quality)) { pet.exp -= this.getRequiredExp(pet.level, pet.quality); pet.level += 1; levelUpCount++; } // 4. 升级后属性计算（逻辑复杂且容易出错） if (levelUpCount \u0026gt; 0) { pet.hp += levelUpCount * 10 * this.getQualityMultiplier(pet.quality); pet.attack += levelUpCount * 5 * this.getQualityMultiplier(pet.quality); // 5. 发送通知 await this.sendLevelUpNotification(petId, pet.level); } // 6. 保存 await db.query(\u0026#39;UPDATE pets SET level=?, exp=?, hp=?, attack=? WHERE id=?\u0026#39;, [pet.level, pet.exp, pet.hp, pet.attack, petId]); return pet; } getRequiredExp(level, quality) { // 升级所需经验计算逻辑 const base = 100 * level; return quality === \u0026#39;epic\u0026#39; ? base * 1.5 : quality === \u0026#39;rare\u0026#39; ? base * 1.2 : base; } getQualityMultiplier(quality) { return quality === \u0026#39;epic\u0026#39; ? 1.5 : quality === \u0026#39;rare\u0026#39; ? 1.2 : 1.0; } } 问题：\n业务逻辑全在Service层，代码臃肿 Pet只是数据容器，没有行为 升级规则、属性计算散落各处 难以保证宠物状态的一致性 测试困难，需要mock数据库 DDD实现方式 1. 值对象（Value Object）- 经验值 // 值对象：经验值 class Experience { constructor(current, level, quality) { if (current \u0026lt; 0) throw new Error(\u0026#39;经验值不能为负\u0026#39;); this.current = current; this.level = level; this.quality = quality; } // 获取升级所需经验 getRequiredForNextLevel() { const baseExp = 100 * this.level; const multiplier = { \u0026#39;common\u0026#39;: 1.0, \u0026#39;rare\u0026#39;: 1.2, \u0026#39;epic\u0026#39;: 1.5 }[this.quality] || 1.0; return Math.floor(baseExp * multiplier); } // 添加经验，返回新的Experience对象（值对象不可变） add(value) { return new Experience( this.current + value, this.level, this.quality ); } // 检查是否可以升级 canLevelUp() { return this.current \u0026gt;= this.getRequiredForNextLevel(); } // 消耗升级所需经验 consumeForLevelUp() { const required = this.getRequiredForNextLevel(); return new Experience( this.current - required, this.level + 1, this.quality ); } } 2. 值对象 - 宠物属性 // 值对象：属性 class PetStats { constructor(hp, attack, level, quality) { this.hp = hp; this.attack = attack; this.level = level; this.quality = quality; } // 升级后的属性 levelUp() { const multiplier = { \u0026#39;common\u0026#39;: 1.0, \u0026#39;rare\u0026#39;: 1.2, \u0026#39;epic\u0026#39;: 1.5 }[this.quality] || 1.0; return new PetStats( this.hp + Math.floor(10 * multiplier), this.attack + Math.floor(5 * multiplier), this.level + 1, this.quality ); } } 3. 领域事件 // 领域事件：宠物升级事件 class PetLeveledUpEvent { constructor(petId, oldLevel, newLevel, stats) { this.petId = petId; this.oldLevel = oldLevel; this.newLevel = newLevel; this.stats = stats; this.occurredAt = new Date(); } } // 领域事件：宠物喂养事件 class PetFedEvent { constructor(petId, foodValue, gainedExp) { this.petId = petId; this.foodValue = foodValue; this.gainedExp = gainedExp; this.occurredAt = new Date(); } } 4. 实体/聚合根 - 宠物 // 聚合根：宠物 class Pet { constructor(id, name, quality, experience, stats) { this.id = id; this.name = name; this.quality = quality; // \u0026#39;common\u0026#39;, \u0026#39;rare\u0026#39;, \u0026#39;epic\u0026#39; this.experience = experience; // Experience值对象 this.stats = stats; // PetStats值对象 this.domainEvents = []; // 领域事件列表 } // 喂养宠物 feed(foodValue) { if (foodValue \u0026lt;= 0) { throw new Error(\u0026#39;食物价值必须大于0\u0026#39;); } // 添加经验 const oldExp = this.experience; this.experience = this.experience.add(foodValue); // 记录喂养事件 this.addDomainEvent(new PetFedEvent( this.id, foodValue, foodValue )); // 尝试升级 this.tryLevelUp(); } // 尝试升级（私有业务逻辑） tryLevelUp() { let levelUpCount = 0; // 循环升级（处理一次喂养多次升级的情况） while (this.experience.canLevelUp()) { const oldLevel = this.stats.level; // 消耗经验 this.experience = this.experience.consumeForLevelUp(); // 提升属性 this.stats = this.stats.levelUp(); levelUpCount++; // 触发升级事件 this.addDomainEvent(new PetLeveledUpEvent( this.id, oldLevel, this.stats.level, { hp: this.stats.hp, attack: this.stats.attack } )); } return levelUpCount; } // 添加领域事件 addDomainEvent(event) { this.domainEvents.push(event); } // 获取并清空领域事件 pullDomainEvents() { const events = [...this.domainEvents]; this.domainEvents = []; return events; } // 获取当前等级 getLevel() { return this.stats.level; } // 获取当前经验进度（百分比） getExpProgress() { const required = this.experience.getRequiredForNextLevel(); return (this.experience.current / required * 100).toFixed(2); } } 5. 仓储接口 // 仓储接口 class IPetRepository { async findById(petId) { throw new Error(\u0026#39;Not implemented\u0026#39;); } async save(pet) { throw new Error(\u0026#39;Not implemented\u0026#39;); } } // 仓储实现 class PetRepository extends IPetRepository { constructor(db) { super(); this.db = db; } async findById(petId) { const data = await this.db.query( \u0026#39;SELECT * FROM pets WHERE id = ?\u0026#39;, [petId] ); if (!data) return null; // 从数据重建领域对象 return new Pet( data.id, data.name, data.quality, new Experience(data.exp, data.level, data.quality), new PetStats(data.hp, data.attack, data.level, data.quality) ); } async save(pet) { // 保存聚合根 await this.db.query( `UPDATE pets SET level = ?, exp = ?, hp = ?, attack = ? WHERE id = ?`, [ pet.stats.level, pet.experience.current, pet.stats.hp, pet.stats.attack, pet.id ] ); // 发布领域事件 const events = pet.pullDomainEvents(); for (const event of events) { await this.publishEvent(event); } } async publishEvent(event) { // 发布事件到事件总线 // 例如：发送通知、更新排行榜等 console.log(\u0026#39;Domain Event:\u0026#39;, event); } } 6. 应用服务（简洁的业务逻辑编排层） // 应用服务：只负责编排，不包含业务逻辑 class PetApplicationService { constructor(petRepository) { this.petRepository = petRepository; } async feedPet(petId, foodValue) { // 1. 加载聚合根 const pet = await this.petRepository.findById(petId); if (!pet) { throw new Error(\u0026#39;宠物不存在\u0026#39;); } // 2. 执行业务逻辑（在领域模型中） pet.feed(foodValue); // 3. 持久化 await this.petRepository.save(pet); // 4. 返回结果 return { level: pet.getLevel(), exp: pet.experience.current, expProgress: pet.getExpProgress(), hp: pet.stats.hp, attack: pet.stats.attack }; } } 7. 使用示例 // 使用 const petService = new PetApplicationService(petRepository); // 喂养宠物 const result = await petService.feedPet(\u0026#39;pet-123\u0026#39;, 250); console.log(`宠物升级到${result.level}级，经验进度${result.expProgress}%`); // 业务逻辑都在领域模型中，应用服务非常简洁 更进一步 在实际业务中,我们常常需要在保持核心流程不变的情况下,允许不同的业务场景有定制化的逻辑。这时可以进一步通过扩展点模式来实现。\n业务场景扩展 假设我们的宠物系统需要支持不同类型的喂养策略：\n普通宠物：直接获得经验 VIP宠物：获得经验加成,并有额外的属性提升 传说宠物：喂养时触发特殊效果,可能获得额外奖励 完整类型定义 首先,定义完整的类型系统：\n// ============= 基础类型定义 ============= // 奖励类型 type RewardType = \u0026#39;gold\u0026#39; | \u0026#39;diamond\u0026#39; | \u0026#39;special_item\u0026#39; | \u0026#39;rare_event\u0026#39;; // 奖励接口 interface Reward { type: RewardType; amount?: number; itemId?: string; eventId?: string; reason: string; } // 连击状态 type ComboStatus = \u0026#39;GOOD\u0026#39; | \u0026#39;GREAT!\u0026#39; | \u0026#39;AMAZING!\u0026#39;; // 宠物等级评级 type PetRank = \u0026#39;C级普通\u0026#39; | \u0026#39;B级稀有\u0026#39; | \u0026#39;A级史诗\u0026#39; | \u0026#39;S级传说\u0026#39;; // VIP等级 type VipLevel = 1 | 2 | 3; // ============= 扩展字段类型定义 ============= // VIP特权信息 interface VipPrivilege { savedFeeds: number; message: string; } // 连击信息 interface ComboInfo { comboCount: number; comboBonus: number; nextComboAt: number; comboStatus: ComboStatus; } // 每日限制信息 interface DailyLimit { remaining: number; total: number; resetAt: number; } // 特殊事件信息 interface SpecialEvents { triggered: boolean; events: Reward[]; message: string; } // 传说统计信息 interface LegendaryStats { totalBonus: number; legendaryBonus: number; efficiency: string; rank: PetRank; } // ============= 返回结果类型定义 ============= // 基础返回结果接口 interface BaseFeedingResponse { level: number; exp: number; expProgress: string; hp: number; attack: number; levelUpCount: number; rewards: Reward[]; } // 普通策略扩展字段 interface NormalFeedingExtensions { feedCount: number; totalExpGained: number; } // VIP策略扩展字段 interface VipFeedingExtensions { vipLevel: VipLevel; expBonus: number; bonusRate: string; vipPrivilege: VipPrivilege; } // 传说策略扩展字段 interface LegendaryFeedingExtensions { comboInfo: ComboInfo; dailyLimit: DailyLimit; specialEvents?: SpecialEvents; legendaryStats: LegendaryStats; } // 组合返回类型 type NormalFeedingResponse = BaseFeedingResponse \u0026amp; NormalFeedingExtensions; type VipFeedingResponse = BaseFeedingResponse \u0026amp; VipFeedingExtensions; type LegendaryFeedingResponse = BaseFeedingResponse \u0026amp; LegendaryFeedingExtensions; // ============= 上下文类型定义 ============= interface FeedingContext { foodValue: number; expBonus: number; actualFoodValue: number; } // ============= 事件管理器接口 ============= interface EventManager { publish(event: any): Promise\u0026lt;void\u0026gt;; } // ============= Pet 相关接口（简化版） ============= interface Pet { id: string; name: string; quality: string; experience: any; stats: any; feed(foodValue: number): void; getLevel(): number; getExpProgress(): string; } interface IPetRepository { findById(petId: string): Promise\u0026lt;Pet | null\u0026gt;; save(pet: Pet): Promise\u0026lt;void\u0026gt;; } 返回结果封装类 // 返回结果基类 class FeedingResult\u0026lt;T extends Record\u0026lt;string, any\u0026gt; = {}\u0026gt; { level: number; exp: number; expProgress: string; hp: number; attack: number; levelUpCount: number; rewards: Reward[]; private extensions: T = {} as T; constructor(pet: Pet, levelUpCount: number, rewards: Reward[]) { this.level = pet.getLevel(); this.exp = pet.experience.current; this.expProgress = pet.getExpProgress(); this.hp = pet.stats.hp; this.attack = pet.stats.attack; this.levelUpCount = levelUpCount; this.rewards = rewards; } // 添加扩展数据（类型安全） addExtension\u0026lt;K extends keyof T\u0026gt;(key: K, value: T[K]): void { this.extensions[key] = value; } // 转换为响应对象 toResponse(): BaseFeedingResponse \u0026amp; T { return { level: this.level, exp: this.exp, expProgress: this.expProgress, hp: this.hp, attack: this.attack, levelUpCount: this.levelUpCount, rewards: this.rewards, ...this.extensions } as BaseFeedingResponse \u0026amp; T; } } 策略接口定义 // 喂养策略扩展点接口 interface IFeedingStrategy\u0026lt;TResponse extends BaseFeedingResponse = BaseFeedingResponse\u0026gt; { // 扩展点1：计算经验加成 calculateExpBonus(pet: Pet, foodValue: number): number; // 扩展点2：喂养前的校验逻辑 beforeFeed(pet: Pet, foodValue: number): Promise\u0026lt;boolean\u0026gt;; // 扩展点3：喂养后的额外处理 afterFeed(pet: Pet, levelUpCount: number): Promise\u0026lt;void\u0026gt;; // 扩展点4：生成奖励 generateRewards(pet: Pet, levelUpCount: number): Reward[]; // 扩展点5：扩展返回结果 extendResult(result: FeedingResult\u0026lt;any\u0026gt;, pet: Pet, context: FeedingContext): void; } // 抽象基础策略类（提供默认实现） abstract class BaseFeedingStrategy\u0026lt;TResponse extends BaseFeedingResponse = BaseFeedingResponse\u0026gt; implements IFeedingStrategy\u0026lt;TResponse\u0026gt; { abstract calculateExpBonus(pet: Pet, foodValue: number): number; async beforeFeed(pet: Pet, foodValue: number): Promise\u0026lt;boolean\u0026gt; { // 默认实现：允许喂养 return true; } async afterFeed(pet: Pet, levelUpCount: number): Promise\u0026lt;void\u0026gt; { // 默认实现：不做任何处理 } abstract generateRewards(pet: Pet, levelUpCount: number): Reward[]; extendResult(result: FeedingResult\u0026lt;any\u0026gt;, pet: Pet, context: FeedingContext): void { // 默认实现：不做任何扩展 } } 应用服务（模板方法） // 基础喂养应用服务（模板方法） class BasePetFeedingService\u0026lt;TResponse extends BaseFeedingResponse = BaseFeedingResponse\u0026gt; { constructor( private readonly petRepository: IPetRepository, private readonly feedingStrategy: IFeedingStrategy\u0026lt;TResponse\u0026gt; ) {} // 模板方法：定义喂养流程骨架 async feedPet(petId: string, foodValue: number): Promise\u0026lt;TResponse\u0026gt; { // 1. 加载聚合根 const pet = await this.petRepository.findById(petId); if (!pet) { throw new Error(\u0026#39;宠物不存在\u0026#39;); } // 2. 扩展点：喂养前校验 const canFeed = await this.feedingStrategy.beforeFeed(pet, foodValue); if (!canFeed) { throw new Error(\u0026#39;当前无法喂养宠物\u0026#39;); } // 3. 扩展点：计算经验加成 const expBonus = this.feedingStrategy.calculateExpBonus(pet, foodValue); const actualFoodValue = foodValue + expBonus; // 4. 执行核心业务逻辑 const oldLevel = pet.getLevel(); pet.feed(actualFoodValue); const newLevel = pet.getLevel(); const levelUpCount = newLevel - oldLevel; // 5. 扩展点：生成奖励 const rewards = this.feedingStrategy.generateRewards(pet, levelUpCount); // 6. 持久化 await this.petRepository.save(pet); // 7. 扩展点：喂养后处理 await this.feedingStrategy.afterFeed(pet, levelUpCount); // 8. 构建基础返回结果 const result = new FeedingResult(pet, levelUpCount, rewards); // 9. 扩展点：扩展返回结果 const context: FeedingContext = { foodValue, expBonus, actualFoodValue }; this.feedingStrategy.extendResult(result, pet, context); // 10. 返回结果 return result.toResponse() as TResponse; } } 业务实现扩展点 1. 普通宠物喂养策略 // 普通宠物喂养策略 class NormalFeedingStrategy extends BaseFeedingStrategy\u0026lt;NormalFeedingResponse\u0026gt; { calculateExpBonus(pet: Pet, foodValue: number): number { // 普通宠物没有加成 return 0; } generateRewards(pet: Pet, levelUpCount: number): Reward[] { // 每升1级给100金币 if (levelUpCount === 0) return []; return [{ type: \u0026#39;gold\u0026#39; as const, amount: 100 * levelUpCount, reason: \u0026#39;宠物升级奖励\u0026#39; }]; } extendResult( result: FeedingResult\u0026lt;NormalFeedingExtensions\u0026gt;, pet: Pet, context: FeedingContext ): void { // 普通策略添加基础统计信息 result.addExtension(\u0026#39;feedCount\u0026#39;, 1); result.addExtension(\u0026#39;totalExpGained\u0026#39;, context.actualFoodValue); } } 2. VIP宠物喂养策略 // VIP宠物喂养策略 class VipFeedingStrategy extends BaseFeedingStrategy\u0026lt;VipFeedingResponse\u0026gt; { constructor(private readonly vipLevel: VipLevel) { super(); } calculateExpBonus(pet: Pet, foodValue: number): number { // VIP玩家获得经验加成 const bonusRates: Record\u0026lt;VipLevel, number\u0026gt; = { 1: 0.1, // VIP1: 10%加成 2: 0.2, // VIP2: 20%加成 3: 0.3 // VIP3: 30%加成 }; return Math.floor(foodValue * bonusRates[this.vipLevel]); } generateRewards(pet: Pet, levelUpCount: number): Reward[] { if (levelUpCount === 0) return []; const rewards: Reward[] = []; // 基础金币奖励 rewards.push({ type: \u0026#39;gold\u0026#39; as const, amount: 100 * levelUpCount, reason: \u0026#39;宠物升级奖励\u0026#39; }); // VIP额外奖励 rewards.push({ type: \u0026#39;diamond\u0026#39; as const, amount: 10 * levelUpCount * this.vipLevel, reason: \u0026#39;VIP专属升级奖励\u0026#39; }); return rewards; } async afterFeed(pet: Pet, levelUpCount: number): Promise\u0026lt;void\u0026gt; { if (levelUpCount \u0026gt; 0) { // VIP玩家升级后发送特殊通知 console.log(`🎉 恭喜VIP${this.vipLevel}玩家，宠物${pet.name}升级到${pet.getLevel()}级！`); } } extendResult( result: FeedingResult\u0026lt;VipFeedingExtensions\u0026gt;, pet: Pet, context: FeedingContext ): void { // VIP策略添加VIP特权信息 result.addExtension(\u0026#39;vipLevel\u0026#39;, this.vipLevel); result.addExtension(\u0026#39;expBonus\u0026#39;, context.expBonus); result.addExtension(\u0026#39;bonusRate\u0026#39;, `${(context.expBonus / context.foodValue * 100).toFixed(1)}%`); // 计算VIP特权节省的时间（假设） const savedFeeds = Math.floor(context.expBonus / context.foodValue); result.addExtension(\u0026#39;vipPrivilege\u0026#39;, { savedFeeds, message: `VIP${this.vipLevel}特权为您节省了${savedFeeds}次喂养` }); } } 3. 传说宠物喂养策略 // 传说宠物喂养策略 class LegendaryFeedingStrategy extends BaseFeedingStrategy\u0026lt;LegendaryFeedingResponse\u0026gt; { private comboCount: number = 0; // 连击次数 private lastFeedTime: number | null = null; constructor(private readonly eventManager: EventManager) { super(); } async beforeFeed(pet: Pet, foodValue: number): Promise\u0026lt;boolean\u0026gt; { // 传说宠物每天只能喂养3次 const feedCountToday = await this.getFeedCountToday(pet.id); if (feedCountToday \u0026gt;= 3) { return false; } // 计算连击 const now = Date.now(); if (this.lastFeedTime \u0026amp;\u0026amp; now - this.lastFeedTime \u0026lt; 5000) { this.comboCount++; } else { this.comboCount = 1; } this.lastFeedTime = now; return true; } calculateExpBonus(pet: Pet, foodValue: number): number { // 连击加成：每连击一次增加20%经验 const comboBonus = Math.floor(foodValue * 0.2 * (this.comboCount - 1)); // 传说宠物基础加成50% const legendaryBonus = Math.floor(foodValue * 0.5); return comboBonus + legendaryBonus; } generateRewards(pet: Pet, levelUpCount: number): Reward[] { if (levelUpCount === 0) return []; const rewards: Reward[] = []; // 基础奖励 rewards.push({ type: \u0026#39;gold\u0026#39; as const, amount: 100 * levelUpCount, reason: \u0026#39;宠物升级奖励\u0026#39; }); // 传说级大额钻石奖励 rewards.push({ type: \u0026#39;diamond\u0026#39; as const, amount: 50 * levelUpCount, reason: \u0026#39;传说宠物升级奖励\u0026#39; }); // 连击奖励 if (this.comboCount \u0026gt;= 3) { rewards.push({ type: \u0026#39;special_item\u0026#39; as const, itemId: \u0026#39;legendary_food\u0026#39;, amount: 1, reason: `${this.comboCount}连击特殊奖励` }); } // 触发稀有事件（概率） if (Math.random() \u0026lt; 0.1) { rewards.push({ type: \u0026#39;rare_event\u0026#39; as const, eventId: \u0026#39;treasure_hunt\u0026#39;, reason: \u0026#39;触发传说事件：寻宝之旅\u0026#39; }); } return rewards; } async afterFeed(pet: Pet, levelUpCount: number): Promise\u0026lt;void\u0026gt; { // 发布传说宠物喂养事件（供其他系统监听） await this.eventManager.publish({ type: \u0026#39;LegendaryPetFed\u0026#39;, petId: pet.id, level: pet.getLevel(), comboCount: this.comboCount, timestamp: Date.now() }); if (levelUpCount \u0026gt; 0) { console.log(`⚡ 传说宠物${pet.name}升级！当前${this.comboCount}连击！`); } } private async getFeedCountToday(petId: string): Promise\u0026lt;number\u0026gt; { // 从缓存或数据库获取今日喂养次数 // 这里简化处理 return 0; } extendResult( result: FeedingResult\u0026lt;LegendaryFeedingExtensions\u0026gt;, pet: Pet, context: FeedingContext ): void { // 传说宠物添加丰富的扩展信息 // 1. 连击系统信息 const comboStatus: ComboStatus = this.comboCount \u0026gt;= 3 ? \u0026#39;AMAZING!\u0026#39; : this.comboCount \u0026gt;= 2 ? \u0026#39;GREAT!\u0026#39; : \u0026#39;GOOD\u0026#39;; result.addExtension(\u0026#39;comboInfo\u0026#39;, { comboCount: this.comboCount, comboBonus: Math.floor(context.foodValue * 0.2 * (this.comboCount - 1)), nextComboAt: this.lastFeedTime! + 5000, comboStatus }); // 2. 今日剩余喂养次数 result.addExtension(\u0026#39;dailyLimit\u0026#39;, { remaining: 2, // 简化处理，实际应该查询 total: 3, resetAt: new Date().setHours(24, 0, 0, 0) }); // 3. 特殊事件触发记录 const specialRewards = result.rewards.filter(r =\u0026gt; r.type === \u0026#39;rare_event\u0026#39; || r.type === \u0026#39;special_item\u0026#39; ); if (specialRewards.length \u0026gt; 0) { result.addExtension(\u0026#39;specialEvents\u0026#39;, { triggered: true, events: specialRewards, message: \u0026#39;⚡ 恭喜触发传说事件！\u0026#39; }); } // 4. 传说宠物专属统计 result.addExtension(\u0026#39;legendaryStats\u0026#39;, { totalBonus: context.expBonus, legendaryBonus: Math.floor(context.foodValue * 0.5), efficiency: `${((context.actualFoodValue / context.foodValue - 1) * 100).toFixed(0)}%`, rank: this.calculateRank(pet.getLevel()) }); } private calculateRank(level: number): PetRank { if (level \u0026gt;= 50) return \u0026#39;S级传说\u0026#39;; if (level \u0026gt;= 30) return \u0026#39;A级史诗\u0026#39;; if (level \u0026gt;= 20) return \u0026#39;B级稀有\u0026#39;; return \u0026#39;C级普通\u0026#39;; } } 使用示例 // 根据不同业务场景选择策略 // 1. 普通玩家喂养（返回类型为 NormalFeedingResponse） const normalService = new BasePetFeedingService\u0026lt;NormalFeedingResponse\u0026gt;( petRepository, new NormalFeedingStrategy() ); const result1: NormalFeedingResponse = await normalService.feedPet(\u0026#39;pet-123\u0026#39;, 100); console.log(\u0026#39;普通玩家结果:\u0026#39;, result1); /* 输出: { level: 5, exp: 50, expProgress: \u0026#39;50.00%\u0026#39;, hp: 150, attack: 75, levelUpCount: 1, rewards: [{ type: \u0026#39;gold\u0026#39;, amount: 100, reason: \u0026#39;宠物升级奖励\u0026#39; }], feedCount: 1, totalExpGained: 100 } */ // 2. VIP玩家喂养（返回类型为 VipFeedingResponse） const vipService = new BasePetFeedingService\u0026lt;VipFeedingResponse\u0026gt;( petRepository, new VipFeedingStrategy(2) // VIP等级2 ); const result2: VipFeedingResponse = await vipService.feedPet(\u0026#39;pet-456\u0026#39;, 100); console.log(\u0026#39;VIP玩家结果:\u0026#39;, result2); /* 输出: { level: 5, exp: 70, expProgress: \u0026#39;70.00%\u0026#39;, hp: 150, attack: 75, levelUpCount: 1, rewards: [ { type: \u0026#39;gold\u0026#39;, amount: 100, reason: \u0026#39;宠物升级奖励\u0026#39; }, { type: \u0026#39;diamond\u0026#39;, amount: 20, reason: \u0026#39;VIP专属升级奖励\u0026#39; } ], vipLevel: 2, expBonus: 20, bonusRate: \u0026#39;20.0%\u0026#39;, vipPrivilege: { savedFeeds: 0, message: \u0026#39;VIP2特权为您节省了0次喂养\u0026#39; } } */ // 3. 传说宠物喂养（连击3次，返回类型为 LegendaryFeedingResponse） const legendaryService = new BasePetFeedingService\u0026lt;LegendaryFeedingResponse\u0026gt;( petRepository, new LegendaryFeedingStrategy(eventManager) ); const result3: LegendaryFeedingResponse = await legendaryService.feedPet(\u0026#39;pet-789\u0026#39;, 100); console.log(\u0026#39;传说宠物结果:\u0026#39;, result3); /* 输出: { level: 6, exp: 100, expProgress: \u0026#39;83.33%\u0026#39;, hp: 180, attack: 90, levelUpCount: 1, rewards: [ { type: \u0026#39;gold\u0026#39;, amount: 100, reason: \u0026#39;宠物升级奖励\u0026#39; }, { type: \u0026#39;diamond\u0026#39;, amount: 50, reason: \u0026#39;传说宠物升级奖励\u0026#39; }, { type: \u0026#39;special_item\u0026#39;, itemId: \u0026#39;legendary_food\u0026#39;, amount: 1, reason: \u0026#39;3连击特殊奖励\u0026#39; } ], comboInfo: { comboCount: 3, comboBonus: 40, nextComboAt: 1696852345000, comboStatus: \u0026#39;AMAZING!\u0026#39; }, dailyLimit: { remaining: 2, total: 3, resetAt: 1696867200000 }, specialEvents: { triggered: true, events: [ { type: \u0026#39;special_item\u0026#39;, itemId: \u0026#39;legendary_food\u0026#39;, amount: 1, reason: \u0026#39;3连击特殊奖励\u0026#39; } ], message: \u0026#39;⚡ 恭喜触发传说事件！\u0026#39; }, legendaryStats: { totalBonus: 90, legendaryBonus: 50, efficiency: \u0026#39;90%\u0026#39;, rank: \u0026#39;C级普通\u0026#39; } } */ 扩展点模式的优势 开闭原则：\n核心流程（feedPet方法）保持稳定,无需修改 新增业务类型只需实现新的策略类 职责清晰：\nBasePetFeedingService：负责流程编排 策略类：负责具体业务逻辑 领域模型：负责核心业务规则 FeedingResult：负责结构化返回数据 返回结果可扩展：\n定义了统一的 FeedingResult 接口 每个策略可以通过 extendResult 添加自己的扩展字段 客户端获得完整且类型安全的响应数据 避免了返回结果的\u0026quot;上帝对象\u0026quot;问题 易于测试：\n// 可以轻松mock策略进行测试 test(\u0026#39;喂养流程应该调用所有扩展点\u0026#39;, async () =\u0026gt; { const mockStrategy = { beforeFeed: jest.fn().mockResolvedValue(true), calculateExpBonus: jest.fn().mockReturnValue(50), generateRewards: jest.fn().mockReturnValue([]), afterFeed: jest.fn() }; const service = new BasePetFeedingService(mockRepo, mockStrategy); await service.feedPet(\u0026#39;pet-1\u0026#39;, 100); expect(mockStrategy.beforeFeed).toHaveBeenCalled(); expect(mockStrategy.calculateExpBonus).toHaveBeenCalled(); expect(mockStrategy.generateRewards).toHaveBeenCalled(); expect(mockStrategy.afterFeed).toHaveBeenCalled(); }); 灵活组合：\n// 可以通过组合模式支持多种策略叠加 class CompositeStrategy extends IFeedingStrategy { constructor(strategies) { super(); this.strategies = strategies; } calculateExpBonus(pet, foodValue) { return this.strategies.reduce( (total, strategy) =\u0026gt; total + strategy.calculateExpBonus(pet, foodValue), 0 ); } async afterFeed(pet, levelUpCount) { for (const strategy of this.strategies) { await strategy.afterFeed(pet, levelUpCount); } } } // 同时应用VIP和节日双倍经验 const compositeService = new BasePetFeedingService( petRepository, new CompositeStrategy([ new VipFeedingStrategy(3), new HolidayBonusStrategy() ]) ); 运行时切换：\n// 可以根据运行时条件动态选择策略 function createFeedingService(user, pet) { let strategy; if (pet.quality === \u0026#39;legendary\u0026#39;) { strategy = new LegendaryFeedingStrategy(eventManager); } else if (user.vipLevel \u0026gt; 0) { strategy = new VipFeedingStrategy(user.vipLevel); } else { strategy = new NormalFeedingStrategy(); } return new BasePetFeedingService(petRepository, strategy); } 架构示意图 classDiagram class BasePetFeedingService { -petRepository -feedingStrategy +feedPet(petId, foodValue) } class IFeedingStrategy { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +calculateExpBonus(pet, foodValue) +beforeFeed(pet, foodValue) +afterFeed(pet, levelUpCount) +generateRewards(pet, levelUpCount) } class NormalFeedingStrategy { +calculateExpBonus() +generateRewards() } class VipFeedingStrategy { -vipLevel +calculateExpBonus() +generateRewards() +afterFeed() } class LegendaryFeedingStrategy { -eventManager -comboCount +beforeFeed() +calculateExpBonus() +generateRewards() +afterFeed() } BasePetFeedingService --\u0026gt; IFeedingStrategy : 依赖 IFeedingStrategy \u0026lt;|.. NormalFeedingStrategy : 实现 IFeedingStrategy \u0026lt;|.. VipFeedingStrategy : 实现 IFeedingStrategy \u0026lt;|.. LegendaryFeedingStrategy : 实现 通过这种扩展点设计,我们实现了：\n统一流程：所有宠物喂养都遵循相同的流程骨架 差异化定制：不同业务场景可以定制自己的逻辑 解耦扩展：新增业务类型不影响现有代码 便于维护：每个策略职责单一,易于理解和修改 这正是 DDD 中\u0026quot;将可变的业务逻辑与稳定的流程分离\u0026quot;的最佳实践。\n项目结构 目录结构\nbase 中包含基础设施（infrastructure）和功能组件（component）和骨架实现（skeleton）\n基础设施主要指的是一些二三方的依赖的封装，通过内部API的形式进行提供 功能组件就是一些相对完整，独立的功能模块 骨架实现一般是一些功能接维度的通用骨架逻辑实现，包含接口请求来的参数校验、核心处理、结构封装返回等 sdk 是接口定义和契约层，base 中针对SDK 中定义的接口进行实现，sdk 中主要包含系统的所有接口、策略扩展点、数据模型、常量和工具类\nmodule 则是具体的游戏业务实现，会引用SDK，但是不直接引用base，完成具体的策略扩展点的重写，从而实现定制化的业务功能\n. ├── base │ ├── component │ ├── infrastructure │ └── skeleton ├── sdk └── module └── gameBusiness 依赖关系图\nflowchart TB subgraph subGraph0[\u0026#34;业务模块层 (module)\u0026#34;] PM[\u0026#34;promotion-module\u0026#34;] P618[\u0026#34;promotion618\u0026#34;] P1111[\u0026#34;promotion1111\u0026#34;] end subgraph subGraph1[\u0026#34;SDK层 (sdk)\u0026#34;] SDK[\u0026#34;sdk\u0026#34;] SDK_COMMON[\u0026#34;sdk/common\u0026#34;] SDK_COMPONENT[\u0026#34;sdk/component\u0026#34;] SDK_INFRA[\u0026#34;sdk/infrastructure\u0026#34;] SDK_SKELETON[\u0026#34;sdk/skeleton\u0026#34;] end subgraph subGraph2[\u0026#34;基础实现层 (base)\u0026#34;] BASE[\u0026#34;base\u0026#34;] BASE_INFRA[\u0026#34;infrastructure\u0026#34;] BASE_COMPONENT[\u0026#34;component\u0026#34;] BASE_SKELETON[\u0026#34;skeleton\u0026#34;] BASE_DRAW[\u0026#34;draw\u0026#34;] BASE_PET[\u0026#34;pet\u0026#34;] end PM --\u0026gt; P618 \u0026amp; P1111 SDK --\u0026gt; SDK_COMMON \u0026amp; SDK_COMPONENT \u0026amp; SDK_INFRA \u0026amp; SDK_SKELETON BASE --\u0026gt; BASE_INFRA \u0026amp; BASE_COMPONENT \u0026amp; BASE_SKELETON BASE_COMPONENT --\u0026gt; BASE_DRAW BASE_SKELETON --\u0026gt; BASE_PET PM -. 依赖 .-\u0026gt; SDK P618 -. 依赖 .-\u0026gt; SDK P1111 -. 依赖 .-\u0026gt; SDK BASE_INFRA -. 依赖 .-\u0026gt; SDK BASE_COMPONENT -. 依赖 .-\u0026gt; SDK \u0026amp; BASE_INFRA BASE_SKELETON -. 依赖 .-\u0026gt; SDK \u0026amp; BASE_INFRA DDD方式的优势 通过上面的对比可以看到：\n业务逻辑内聚：\n经验计算、升级判断、属性提升都封装在对应的领域对象中 Service层变得非常薄，只负责编排 易于测试：\n// 单元测试不需要数据库 test(\u0026#39;宠物喂养后应该获得经验\u0026#39;, () =\u0026gt; { const pet = new Pet( \u0026#39;1\u0026#39;, \u0026#39;Pikachu\u0026#39;, \u0026#39;rare\u0026#39;, new Experience(0, 1, \u0026#39;rare\u0026#39;), new PetStats(100, 50, 1, \u0026#39;rare\u0026#39;) ); pet.feed(100); expect(pet.experience.current).toBe(100); }); test(\u0026#39;史诗宠物升级所需经验更多\u0026#39;, () =\u0026gt; { const exp1 = new Experience(0, 1, \u0026#39;common\u0026#39;); const exp2 = new Experience(0, 1, \u0026#39;epic\u0026#39;); expect(exp2.getRequiredForNextLevel()) .toBeGreaterThan(exp1.getRequiredForNextLevel()); }); 业务规则清晰可见：\n代码直接表达业务概念：pet.feed(), experience.canLevelUp() 新人可以通过阅读领域模型快速理解业务 易于扩展：\n添加新品质的宠物？只需修改值对象中的配置 修改升级公式？只在Experience中修改 添加新的宠物行为？在Pet实体中添加方法 事件驱动：\n通过领域事件解耦副作用（通知、日志、统计等） 便于实现复杂的业务流程 状态一致性：\n聚合根保证宠物状态的一致性 不会出现\u0026quot;经验已扣除但等级未提升\u0026quot;的情况 NodeJS上现有的实现 white-label是基于源码级别的 Domain-Driven Design Demo，有非常高的参考性\ntype-ddd 这个是NodeJS中针对是 Domain-Driven Design 的一个封装，主要是提供utils、 Entity、Value Objects、Factories、Aggregates、Repository、Domain events等来建立复杂的应用，可以看下项目的 README 有最基本的用法示例\n针对这两个项目，可以先看下 white-label，之后实践过程中则可以使用 type-ddd 进行具体的编码实现\n参考资料 DDD中类型接口：https://github.com/4lessandrodev/type-ddd DDD教程：https://github.com/stemmlerjs/ddd-forum NodeJS 中的示例： https://github.com/stemmlerjs/white-label Rich-Domain:https://github.com/4lessandrodev/rich-domain ","permalink":"https://genluo.github.io/my-blog/posts/ddd/","summary":"\u003ch2 id=\"契机\"\u003e契机\u003c/h2\u003e\n\u003cp\u003e最近因为一些契机看了下互动小游戏的服务端，深入了解了下现在互动游戏服务端的架构，同时也尝试在这个架构的基础上使用 AI 进行一些游戏业务功能开发，其中印象最深的服务端的一个称之为基座的架构设计，这个基座架构深度使用 \u003ccode\u003eDDD\u003c/code\u003e 领域设计思想进行抽象实现，在游戏业务非常灵活，复用性非常高，所以想看下在\u003ccode\u003eNodeJS\u003c/code\u003e 中针对 \u003ccode\u003eDDD\u003c/code\u003e领域驱动设计是否有一定的实践。下面主要分为两个部分，一个是为什么是\u003ccode\u003eDDD\u003c/code\u003e？另一个 \u003ccode\u003eNodeJS\u003c/code\u003e中一些实践\u003c/p\u003e\n\u003ch2 id=\"ddd\"\u003e\u003ccode\u003eDDD\u003c/code\u003e\u003c/h2\u003e\n\u003ch3 id=\"什么是领域驱动设计domain-driving-design\"\u003e什么是领域驱动设计（domain driving design）\u003c/h3\u003e\n\u003cp\u003e领域驱动设计是一种软件设计方法，用于表示和组织特定领域中的知识和业务逻辑。它主要通过创建抽象的模型对象来模拟现实世界的实体及其关系，帮助开发人员理解和实现复杂系统的业务逻辑。在领域驱动设计中，通常会包含以下几个关键概念：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e实体（Entity）\u003c/strong\u003e：具有唯一标识的对象，通常表示业务中的一个独立的概念或对象。例如，在一个订单系统中，订单和客户可以被视为实体。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e值对象（Value Object）\u003c/strong\u003e：没有唯一标识的对象，通常用于描述某个实体的属性或细节。它们是不可变的，两个值对象如果具有相同的属性值，则认为是相等的。例如，一个地址可以作为一个值对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e聚合（Aggregate）\u003c/strong\u003e：一组相关的对象（实体和值对象）的集合，它们被视为一个单元进行数据修改。聚合有一个根实体（Aggregate Root），通过根实体来管理聚合的生命周期。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e领域服务（Domain Service）\u003c/strong\u003e：封装领域逻辑的操作，这些操作不属于任何一个实体或值对象。它们通常用于表示跨越多个实体或值对象的业务逻辑。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e仓储（Repository）\u003c/strong\u003e：提供访问持久化存储中对象的方法，通常用于获取和保存聚合根。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"什么是聚合根\"\u003e什么是聚合根\u003c/h4\u003e\n\u003cp\u003e指的是一个聚合中具有唯一标识的核心实体，该实体负责控制整个聚合的生命周期和一致性。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e控制访问\u003c/strong\u003e：聚合根是聚合内的唯一入口点，外部对象只能通过聚合根来访问或操作聚合中的其它对象。这有助于保持聚合内部的完整性和一致性。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e管理生命周期\u003c/strong\u003e：聚合根负责管理聚合内所有对象的生命周期，包括创建、更新和删除操作。通过聚合根，可以确保对聚合中数据的任何修改都是合法和一致的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e一致性边界\u003c/strong\u003e：聚合定义了一个一致性边界，其中的所有对象在事务中应该保持一致。因此，聚合根通过确保在其范围内的操作都是一致的，来维持这种边界。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e唯一性\u003c/strong\u003e：每个聚合都有一个唯一的聚合根。通常，聚合根具有唯一标识符，用来标识和访问该聚合。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e持久化管理\u003c/strong\u003e：通过仓储（Repository）模式，聚合根通常是持久化操作（如保存和检索）的主要对象。这意味着仓储通常只直接处理聚合根，而不是聚合内的其它对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"领域驱动设计优缺点\"\u003e领域驱动设计优缺点\u003c/h3\u003e\n\u003cp\u003e领域驱动设计（Domain-Driven Design, DDD）是一种软件设计方法，旨在通过紧密结合业务需求和技术实现来构建复杂软件系统。以下是领域驱动设计的一些优缺点：\u003c/p\u003e\n\u003ch4 id=\"优点\"\u003e优点\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e更好地理解业务\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDDD强调与领域专家的密切合作，使开发团队对业务需求有更深入的理解。这有助于创建更符合业务需求的系统。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e清晰的模型\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过使用统一语言和领域模型，所有团队成员（包括技术人员和非技术人员）都可以在同一语境下沟通，从而减少误解。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e灵活性和可维护性\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDDD鼓励模块化设计，如界限上下文（Bounded Context）和聚合（Aggregate），这些设计有助于简化系统的维护和扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e关注核心领域\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过识别和聚焦于核心领域，DDD帮助团队将资源集中在对业务最重要的部分，从而提高竞争力。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e支持复杂系统开发\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDDD为处理复杂领域逻辑提供了有力的方法和工具，可以有效地管理复杂性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"缺点\"\u003e缺点\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e学习曲线陡峭\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对许多开发人员和组织来说，DDD的概念和技术术语可能较为陌生，初始学习和实施成本较高。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e时间和资源投入大\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e由于需要深度的领域分析和持续的团队协作，DDD可能比传统方法花费更多时间和资源。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e不适合所有项目\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于简单或小型项目，DDD可能过于复杂和冗余，投入的成本和收益不成比例。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e需求稳定性要求高\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDDD更适合于需求相对稳定且对业务逻辑要求高的项目。对于需求频繁变化的项目，可能需要经常重构。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e对团队协作要求高\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e成功实施DDD需要团队成员之间良好的沟通和协作，这对团队的组织文化和沟通能力提出了较高要求。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"为什么需要领域模型\"\u003e为什么需要领域模型\u003c/h3\u003e\n\u003cp\u003e在传统的软件开发中,我们常常遇到以下问题：\u003c/p\u003e\n\u003ch4 id=\"1-贫血模型的困境\"\u003e1. 贫血模型的困境\u003c/h4\u003e\n\u003cp\u003e传统的开发方式往往采用\u0026quot;贫血模型\u0026quot;（Anemic Domain Model），即：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e数据对象只包含字段和简单的 getter/setter\u003c/strong\u003e，没有任何业务逻辑\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e所有业务逻辑集中在 Service 层\u003c/strong\u003e，形成庞大的服务类\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据和行为分离\u003c/strong\u003e，导致代码难以理解和维护\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-业务逻辑散乱\"\u003e2. 业务逻辑散乱\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e缺乏统一的业务规则管理\u003c/strong\u003e：同样的业务逻辑可能在多个地方重复实现\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e难以保证一致性\u003c/strong\u003e：订单创建、修改、取消等操作中的业务规则可能不一致\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e维护成本高\u003c/strong\u003e：修改一个业务规则需要在多个地方查找和修改\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-技术与业务脱节\"\u003e3. 技术与业务脱节\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e代码难以反映业务意图\u003c/strong\u003e：开发人员看到的是表、字段、SQL，而不是订单、支付、发货等业务概念\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e与领域专家沟通困难\u003c/strong\u003e：技术术语和业务术语无法对应，容易产生理解偏差\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e需求变更代价大\u003c/strong\u003e：业务调整时，需要从底层数据结构开始重新设计\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"领域模型如何解决这些问题\"\u003e领域模型如何解决这些问题\u003c/h4\u003e\n\u003cp\u003e领域模型通过以下方式解决上述问题：\u003c/p\u003e","title":"领域驱动设计"},{"content":"# .clang-format BasedOnStyle: LLVM # 可选：LLVM, Google, Chromium, Mozilla, WebKit IndentWidth: 4 TabWidth: 4 UseTab: Never # 可选：Always, Never, ForIndentation ColumnLimit: 100 # 每行最大字符数，设为 0 表示不限制 BreakBeforeBraces: Allman # 可选：Attach, Linux, Stroustrup, Allman, WebKit AllowShortIfStatementsOnASingleLine: false AllowShortLoopsOnASingleLine: false AllowShortFunctionsOnASingleLine: Inline SpaceAfterCStyleCast: true SpacesInParentheses: false SpaceBeforeParens: ControlStatements # 控制语句前加空格，如 `if (...)` PointerAlignment: Left # 可选：Left, Right, Middle SortIncludes: true IncludeBlocks: Regroup # 对齐参数 AlignAfterOpenBracket: Align AlignConsecutiveAssignments: true AlignConsecutiveDeclarations: true AlignOperands: true # 命名空间格式 NamespaceIndentation: All # 可选：None, Inner, All # 结构体/类格式 AccessModifierOffset: -4 # public/private/protected 的缩进 # 注释格式 IndentWrappedFunctionNames: true ","permalink":"https://genluo.github.io/my-blog/posts/clangformat/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-toml\" data-lang=\"toml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# .clang-format\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eBasedOnStyle\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eLLVM\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 可选：LLVM, Google, Chromium, Mozilla, WebKit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eIndentWidth\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eTabWidth\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eUseTab\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eNever\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 可选：Always, Never, ForIndentation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eColumnLimit\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 每行最大字符数，设为 0 表示不限制\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eBreakBeforeBraces\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAllman\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 可选：Attach, Linux, Stroustrup, Allman, WebKit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAllowShortIfStatementsOnASingleLine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAllowShortLoopsOnASingleLine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAllowShortFunctionsOnASingleLine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eInline\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eSpaceAfterCStyleCast\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eSpacesInParentheses\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eSpaceBeforeParens\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eControlStatements\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 控制语句前加空格，如 `if (...)`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ePointerAlignment\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eLeft\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 可选：Left, Right, Middle\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eSortIncludes\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eIncludeBlocks\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eRegroup\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 对齐参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAlignAfterOpenBracket\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAlign\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAlignConsecutiveAssignments\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAlignConsecutiveDeclarations\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAlignOperands\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 命名空间格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eNamespaceIndentation\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAll\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 可选：None, Inner, All\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 结构体/类格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eAccessModifierOffset\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e-4\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# public/private/protected 的缩进\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 注释格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eIndentWrappedFunctionNames\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Clangformat"},{"content":"ReaderWriterQueue 是一个高性能的 C++无锁队列实现，专为单生产者-单消费者（SPSC）场景设计。\n无锁设计：完全无锁实现，enqueue 和 dequeue 操作都是 O(1)时间复杂度 高性能：在 x86 架构上，内存屏障编译为无操作指令，性能极佳 C++11 兼容：支持移动语义，减少不必要的拷贝 泛型模板：使用模版支持任意类型的元素，类似 std::queue 内存高效：预分配连续内存块，提供 try_enqueue 保证不分配内存 阻塞版本：提供 BlockingReaderWriterQueue 支持 wait_dequeue 操作 适用于需要在两个线程间高效传递数据的场景，如生产者-消费者模式、异步任务处理等。仅需包含头文件即可使用，无需额外依赖\n核心问题 1. 整体思路 代码中主要包含两个部分，一个是队列链表，这个链表中存储很多的 block，每个 block 内部实现又是一个链表，这个链表，有读写两个指针，可以存放多个线程共享的元素\n2. 内存中结构 存储的数据分为两部分，一部分是 Block 中属性数据+内存对其\nauto size = sizeof(Block) + std::alignment_of\u0026lt;Block\u0026gt;::value - 1; 另一部分则是需要存储的具体数据：\nsize += sizeof(T) * capacity + std::alignment_of\u0026lt;T\u0026gt;::value - 1; 针对申请的内容，实际分配内存进行指针对齐\nauto newBlockRaw = static_cast\u0026lt;char *\u0026gt;(std::malloc(size)); auto newBlockAligned = align_for\u0026lt;Block\u0026gt;(newBlockRaw); auto newBlockData = align_for\u0026lt;T\u0026gt;(newBlockAligned + sizeof(Block)); template \u0026lt;typename U\u0026gt; static AE_FORCEINLINE char *align_for(char *ptr) AE_NO_TSAN { const std::size_t alignment = std::alignment_of\u0026lt;U\u0026gt;::value; return ptr + (alignment - (reinterpret_cast\u0026lt;std::uintptr_t\u0026gt;(ptr) % alignment)) % alignment; } 为什么这个过程中需要内存对其，可以看下下面的问题部分，这样对齐之后可以保证：\nBlock 对象的内存访问是高效的 存储在队列中的 T 类型元素也能获得最佳的内存访问性能 避免因为未对齐访问导致的性能损失或在某些架构上的崩溃 3. 如何使用 测试 单元测试 稳定性测试 CRTP 设计模式 通过 CRTP，基类可以调用派生类的方法，实现了静态多态，在这个项目中是这样使用\n核心思想 \u0026ldquo;派生类告诉基类自己是谁\u0026rdquo; - 通过模板参数传递自身类型 静态多态 - 编译时确定调用关系，无运行时开销 类型安全 - 编译时检查，避免类型错误 优势 零运行时开销，相比虚函数性能强大很多（不使用虚函数表） 编译时类型检查（虚函数运行时多态，无法完全被优化） 代码复用（可以使用基类功能，派生类只需要实现特定的功能） 示例 基础示例 // CRTP 方法 template \u0026lt;typename Derived\u0026gt; class CRTPBase { public: int calculate() { return static_cast\u0026lt;Derived *\u0026gt;(this)-\u0026gt;calculate_impl(); } }; class CRTPDerived : public CRTPBase\u0026lt;CRTPDerived\u0026gt; { public: int calculate_impl() { return 42; } }; 测试用例 #define REGISTER_TEST(testName) registerTest(#testName, \u0026amp;subclass_t::testName) template \u0026lt;typename TSubclass\u0026gt; class TestClass { public: typedef TSubclass subclass_t; void registerTest(const char *name, bool (subclass_t::*method)()); }; class Test : public TestClass\u0026lt;Test\u0026gt; { public: Test() { REGISTER_TEST(test1); REGISTER_TEST(test2); } bool test1(); bool test2(); }; 测试过程中预定义宏 我来为您整理一个完整的 C/C++ 预定义宏表格：\nC/C++ 预定义宏表 标准预定义宏 宏名 描述 类型 示例值 __LINE__ 当前行号 整数 42 __FILE__ 当前文件名 字符串 \u0026quot;main.cpp\u0026quot; __DATE__ 编译日期 字符串 \u0026quot;Aug 20 2025\u0026quot; __TIME__ 编译时间 字符串 \u0026quot;14:30:25\u0026quot; __TIMESTAMP__ 文件最后修改时间 字符串 \u0026quot;Mon Aug 20 14:30:25 2025\u0026quot; C++ 函数/作用域相关宏 宏名 描述 类型 示例值 __func__ 当前函数名 (C99/C++11) 字符串 \u0026quot;main\u0026quot; __FUNCTION__ 当前函数名 (GCC 扩展) 字符串 \u0026quot;main\u0026quot; __PRETTY_FUNCTION__ 完整函数签名 (GCC) 字符串 \u0026quot;int main(int, char**)\u0026quot; 标准版本宏 宏名 描述 类型 示例值 __STDC__ 符合标准 C 整数 1 __STDC_VERSION__ C 标准版本 整数 201112L (C11) __cplusplus C++标准版本 整数 201703L (C++17) __STDC_HOSTED__ 是否为宿主环境 整数 1 编译器特定宏 宏名 描述 编译器 示例值 __GNUC__ GCC 主版本号 GCC 11 __GNUC_MINOR__ GCC 次版本号 GCC 3 __clang__ Clang 编译器 Clang 1 _MSC_VER MSVC 版本 MSVC 1930 __INTEL_COMPILER Intel 编译器版本 ICC 2021 平台/架构宏 宏名 描述 平台 示例值 _WIN32 Windows (32/64 位) Windows 1 _WIN64 Windows 64 位 Windows 1 __linux__ Linux 系统 Linux 1 __APPLE__ Apple 平台 macOS/iOS 1 __unix__ Unix 系统 Unix-like 1 __x86_64__ x86-64 架构 64 位 x86 1 __aarch64__ ARM64 架构 ARM64 1 调试相关宏 宏名 描述 类型 备注 NDEBUG 发布模式 整数/未定义 定义时禁用 assert _DEBUG 调试模式 整数 MSVC 特定 DEBUG 调试模式 整数 非标准 特殊用途宏 宏名 描述 类型 用途 __COUNTER__ 递增计数器 整数 每次使用自增 __BASE_FILE__ 主源文件名 字符串 编译单元的基础文件 __INCLUDE_LEVEL__ 包含层级 整数 嵌套包含深度 特性检测宏 (C++11+) 宏名 描述 类型 示例值 __has_include 检查头文件支持 函数宏 __has_include __has_cpp_attribute 检查 C++属性支持 函数宏 __has_cpp_attribute(nodiscard) 数值类型相关宏 宏名 描述 类型 示例值 __SIZEOF_INT__ int 类型字节数 整数 4 __SIZEOF_POINTER__ 指针字节数 整数 8 __CHAR_BIT__ char 位数 整数 8 性能 benchmarks SIMD 优化 问题 1. false sharing 问题 伪共享是指两个或多个 CPU 核心频繁访问同一缓存行中的不同数据，导致缓存行在不同核心之间不断传递，造成性能下降的现象。\n缓存行（64字节）：[变量A][变量B][其他数据...] ↑ ↑ 核心1访问 核心2访问 虽然核心 1 只访问变量 A，核心 2 只访问变量 B，但因为它们在同一缓存行中：\n核心 1 修改变量 A → 整个缓存行失效 核心 2 访问变量 B → 需要重新加载缓存行 核心 2 修改变量 B → 核心 1 的缓存行失效 核心 1 再次访问变量 A → 又需要重新加载\n避免伪共享 使用 cachelineFiller0 将 front 和 tail 分隔到不同缓存行，生产者线程主要访问的 tail 和消费者线程主要访问的 front 不会相互干扰\nstruct Block { weak_atomic\u0026lt;size_t\u0026gt; front; // 消费者主要访问 size_t localTail; // 消费者拥有 // 缓存行填充 - 确保下面的变量在不同缓存行 char cachelineFiller0[MOODYCAMEL_CACHE_LINE_SIZE - sizeof(weak_atomic\u0026lt;size_t\u0026gt;) - sizeof(size_t)]; weak_atomic\u0026lt;size_t\u0026gt; tail; // 生产者主要访问 size_t localFront; // 生产者拥有 // 再次填充 char cachelineFiller1[MOODYCAMEL_CACHE_LINE_SIZE - sizeof(weak_atomic\u0026lt;size_t\u0026gt;) - sizeof(size_t)]; weak_atomic\u0026lt;Block*\u0026gt; next; // ... }; 2. 编译器重排序问题 指令重排序 内粗访问重新排序 循环优化重排序 问题示例 数据竞争：data 和 ready 没有同步保护，同时被多个线程访问 内存重排序：编译器/CPU 可能重排序指令，ready = true 可能在 data = 42 之前执行 可见性问题：一个线程的写操作可能不会立即对另一个线程可见 编译器可能将 producer 中的指令重排序为： // ready = true; // 被提前！ // data = 42;// 被延后！ // 这会导致消费者读取到错误的 data 值\n#include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; int data = 0; bool ready = false; // 线程1：生产者 void producer() { data = 42;// Step 1 ready = true; // Step 2 } // 线程2：消费者 void consumer() { while (!ready) { // 等待 } std::cout \u0026lt;\u0026lt; \u0026#34;Data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; // 期望输出42 } 解决编译器重排序问题 使用 volatile volatile int flag = 0; int data = 0; void producer() { data = 42; flag = 1; // volatile 防止重排序 } void consumer() { while (flag ==0) { // volatile 防止优化 // 等待 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); } 使用 内存屏障 #include \u0026lt;atomic\u0026gt; int data = 0; bool ready = false; void producer() { data = 42; std::atomic_signal_fence(std::memory_order_release); // 编译器屏障 ready = true; } void consumer() { while (!ready) {std::atomic_signal_fence(std::memory_order_acquire); // 编译器屏障 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); } 使用原子操作 #include \u0026lt;atomic\u0026gt; int data = 0; std::atomic\u0026lt;bool\u0026gt; ready{false}; void producer() { data = 42; ready.store(true, std::memory_order_release); // 防止重排序 } void consumer() { while (!ready.load(std::memory_order_acquire)) { // 等待 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); // 保证读取到正确值 } 编译器重排序\u0026amp;CPU 重排序 特性 编译器重排序 CPU 重排序 发生时机 编译时 运行时 影响范围 所有平台 特定 CPU 架构 防护方法 编译器屏障 内存屏障指令 性能影响 编译时优化 运行时开销 实践 单线程通常不用关心，但是多线程需要关系这个问题 3. 信号量 在 Apple iOS and OSX 平台上选用 Mach 信号量的原因： http://lists.apple.com/archives/darwin-kernel/2009/Apr/msg00010.html 4. 内存对齐 内存对齐是指数据在内存中的存储位置必须是某个特定数值的倍数。例如，一个 4 字节的整数可能需要存储在地址为 4 的倍数的位置上。\n对齐的数据可以一次读取，不对其可能需要多次 对齐的数据更容易命中缓存 5. 多线程数据竞争和同步问题 特性/机制 互斥锁 (Mutex) 读写锁 (Shared Mutex) 原子操作 (Atomic Operations) 并发性能 较差，锁竞争时性能下降 较好，读多写少时效果显著 非常好，几乎没有开销 写操作性能 好 差，写操作时锁竞争严重 非常好，原子操作通常不需要锁 读操作性能 较差，阻塞等待锁 好，允许多个读线程并行 非常好，读操作不需要锁 复杂度 低，易于理解和使用 中，管理读写锁和线程竞争 高，只有简单的操作可以用原子操作 适用场景 一般适用于少数临界区的保护 适合读多写少的场景 适合对单个变量的高效操作 开销 高，特别是在锁竞争严重时 中等，读写锁竞争时会有开销 低，原子操作无需阻塞 参考 Readerwriterqueue ","permalink":"https://genluo.github.io/my-blog/posts/readerwriterqueue/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/cameron314/readerwriterqueue\"\u003eReaderWriterQueue\u003c/a\u003e 是一个高性能的 C++无锁队列实现，专为单生产者-单消费者（SPSC）场景设计。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无锁设计：完全无锁实现，enqueue 和 dequeue 操作都是 O(1)时间复杂度\u003c/li\u003e\n\u003cli\u003e高性能：在 x86 架构上，内存屏障编译为无操作指令，性能极佳\u003c/li\u003e\n\u003cli\u003eC++11 兼容：支持移动语义，减少不必要的拷贝\u003c/li\u003e\n\u003cli\u003e泛型模板：使用模版支持任意类型的元素，类似 std::queue\u003c/li\u003e\n\u003cli\u003e内存高效：预分配连续内存块，提供 try_enqueue 保证不分配内存\u003c/li\u003e\n\u003cli\u003e阻塞版本：提供 BlockingReaderWriterQueue 支持 wait_dequeue 操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e适用于需要在两个线程间高效传递数据的场景，如生产者-消费者模式、异步任务处理等。仅需包含头文件即可使用，无需额外依赖\u003c/p\u003e\n\u003ch2 id=\"核心问题\"\u003e核心问题\u003c/h2\u003e\n\u003ch3 id=\"1-整体思路\"\u003e1. 整体思路\u003c/h3\u003e\n\u003cp\u003e代码中主要包含两个部分，一个是队列链表，这个链表中存储很多的 block，每个 block 内部实现又是一个链表，这个链表，有读写两个指针，可以存放多个线程共享的元素\u003c/p\u003e\n\u003ch3 id=\"2-内存中结构\"\u003e2. 内存中结构\u003c/h3\u003e\n\u003cp\u003e存储的数据分为两部分，一部分是 Block 中属性数据+内存对其\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e size \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(Block) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBlock\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e另一部分则是需要存储的具体数据：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esize \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(T) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e capacity \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e针对申请的内容，实际分配内存进行指针对齐\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockRaw \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e(std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003emalloc(size));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockAligned \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e align_for\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBlock\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(newBlockRaw);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockData \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e align_for\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(newBlockAligned \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(Block));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e U\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e AE_FORCEINLINE \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ealign_for(\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eptr) AE_NO_TSAN {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003esize_t alignment \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eU\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ptr \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          (alignment \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ereinterpret_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003estd\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003euintptr_t\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(ptr) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e alignment)) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              alignment;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为什么这个过程中需要内存对其，可以看下下面的问题部分，这样对齐之后可以保证：\u003c/p\u003e","title":"Readerwriterqueue 源代码阅读"},{"content":"基本配置 一般来说，vscode 中开发 c++ 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 clangd ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\n基础配置 如果使用 cmake 进行开发，可以添加编译参数 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 来生成 clangd 需要的 compile_commands.json 来索引整个项目的源文件\n通过 cmake 进行配置生成，包含 bear 工具介绍 generates a compilation database for clang tooling.\n如果使用的是其他的构建系统，没有使用 cmake 可以使用这个工具，生成对应的 compile_commands.json\nbear -- make 重启服务之后，可以正常进行跳转\n","permalink":"https://genluo.github.io/my-blog/posts/vscode+clangd/","summary":"\u003ch2 id=\"基本配置\"\u003e基本配置\u003c/h2\u003e\n\u003cp\u003e一般来说，\u003ccode\u003evscode\u003c/code\u003e 中开发 \u003ccode\u003ec++\u003c/code\u003e 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 \u003ccode\u003eclangd\u003c/code\u003e ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\u003c/p\u003e\n\u003ch3 id=\"基础配置\"\u003e基础配置\u003c/h3\u003e\n\u003cp\u003e如果使用 \u003ccode\u003ecmake\u003c/code\u003e 进行开发，可以添加编译参数 \u003ccode\u003e-DCMAKE_EXPORT_COMPILE_COMMANDS=ON\u003c/code\u003e 来生成 \u003ccode\u003eclangd\u003c/code\u003e 需要的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e 来索引整个项目的源文件\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ecmake\u003c/code\u003e 进行配置生成，包含\n\u003cimg loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-3.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"bear-工具介绍\"\u003e\u003ca href=\"https://github.com/rizsotto/Bear\"\u003ebear\u003c/a\u003e 工具介绍\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003egenerates a compilation database for clang tooling.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果使用的是其他的构建系统，没有使用 \u003ccode\u003ecmake\u003c/code\u003e 可以使用这个工具，生成对应的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebear -- make\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e重启服务之后，可以正常进行跳转\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-5.png\"\u003e\u003c/p\u003e","title":"Vscode+clangd"},{"content":"整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\n要点 内容需要详细，不要概括笼统，月具体越好 让模型充当一个角色，让其更加专业和明确 使用分割符来区分输出的不同部分 指定任务完成的步骤，将复杂任务简化 提供示例，给模型进行参考 指定输出长度 内容 1. 确定角色定义 明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\n要点：\n具体的职业身份（如：高级软件架构师、产品经理、数据分析师） 相关的专业背景和经验 工作场景和责任范围 与用户的关系定位 示例：\n## 角色定义 你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。 2. 确定核心目标 清晰描述希望 AI 完成的主要任务和期望达到的效果。\n要点：\n主要任务的具体描述 预期的输出结果 成功的衡量标准 目标用户和使用场景 示例：\n## 核心目标 - **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档 3. 确定关键规则 设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\n要点：\n约束AI 的行为 内容的准确性标准 禁止的行为或内容 特殊情况的处理方式 示例：\n## 关键规则 - **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节 - **防简化要求**：严格遵循 `./anti-simplification-rules.md` 中的防简化规则，绝对禁止简化、概述、总结原始需求内容 4. 确定执行流程 定义 AI 处理任务的具体步骤和逻辑顺序。\n要点：\n分析问题的步骤 信息收集和处理流程 决策和推理过程 输出生成的顺序 示例：\n## 拆解执行流程 ### 任务1：知识了解 **目标**：深入学习XXX互动游戏框架的核心知识和互动基座架构 **执行清单**： 1. **阅读xxxx文档**： - 仔细阅读 `.xxx.md` 文件 - 重点理解xxxx的定义和概念、功能 2. **阅读xxxx模型文档**： - 仔细阅读 `.xxxx.md` 文件 - 重点理解xxx模型的核心概念、数据结构和业务流程 - 识别关键实体和它们之间的关系 3. **阅读互动基座架构文档**： - 仔细阅读 `.xxxx.md` 文件 - 理解互动基座的整体架构设计、各层职责和模块划分 - 掌握技术实现细节和集成方式 4. **知识整合分析**： - 分析两个文档中的关键信息点 - 建立xxxx模型与互动基座架构之间的映射关系 - 识别业务概念到技术实现的转换路径 ### 任务2：环境准备 **目标**：建立标准化的文档目录结构 **执行清单**： 1. ✅ 检查并创建根目录：`./docs` 2. ✅ 检查并创建需求目录：`./docs/requirements` 3. ✅ 检查并创建子需求目录：`./docs/sub_requirements` 4. ✅ 检查并创建功能设计目录：`./docs/function_designs` 5. ✅ 验证原始需求文件存在：`./docs/requirements/{需求ID}.md` ### 任务3：需求分析与拆解 **目标**：基于xxxx模型进行系统性需求分析 **输出**：需求拆解分析报告 ### 任务4：子需求文档生成 **目标**：创建结构化的子需求文档 **文档规范**： **输出**：完整的子需求文档集合 ### 任务5：一致性保证 **目标**：确保所有文档间的技术一致性 **输出**：技术一致性报告 5. 确定输出模版 规范化输出格式，确保信息的结构化和易读性。\n要点：\n固定的输出结构 各部分的内容要求 格式化规范 示例和模板 示例：\n## 需求文档模版 整体务必遵循 .xxx-split-template.md 模版的格式 输出模版 # [产品包名称]技术方案 \u0026gt; **使用说明：** 本模板适用于XXX互动游戏框架的产品包技术方案设计，请根据实际情况填写各个章节内容。带有 `[占位符]` 的内容需要替换为具体信息。 ## 概述 \u0026gt; **填写指导：** 用1-2句话简洁描述产品包的核心定位和技术实现方式，说明其基于IGF框架的扩展方案。 [产品包名称]是[目标活动/业务场景]的[核心功能定位]，负责[主要功能1]、[主要功能2]、[主要功能3]等功能。本技术方案基于 xxxx 基座的 [骨架名称] 骨架进行扩展实现，采用 IGF [框架类型]框架实现[核心玩法/业务逻辑]。 .... 大模型参数 Temperature：简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。 Top_p：同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。 Max Length：您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。 Stop Sequences：stop sequence 是一个字符串，可以阻止模型生成 token，指定 stop sequences 是控制大模型响应长度和结构的另一种方法。例如，您可以通过添加 “11” 作为 stop sequence 来告诉模型生成不超过 10 个项的列表。 Frequency Penalty：frequency penalty 是对下一个生成的 token 进行惩罚，这个惩罚和 token 在响应和提示中已出现的次数成比例， frequency penalty 越高，某个词再次出现的可能性就越小，这个设置通过给 重复数量多的 Token 设置更高的惩罚来减少响应中单词的重复。 Presence Penalty：presence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。 参考 https://www.promptingguide.ai/zh ","permalink":"https://genluo.github.io/my-blog/posts/prompt/","summary":"\u003cp\u003e整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\u003c/p\u003e\n\u003ch2 id=\"要点\"\u003e要点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e内容需要详细，不要概括笼统，月具体越好\u003c/li\u003e\n\u003cli\u003e让模型充当一个角色，让其更加专业和明确\u003c/li\u003e\n\u003cli\u003e使用分割符来区分输出的不同部分\u003c/li\u003e\n\u003cli\u003e指定任务完成的步骤，将复杂任务简化\u003c/li\u003e\n\u003cli\u003e提供示例，给模型进行参考\u003c/li\u003e\n\u003cli\u003e指定输出长度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"内容\"\u003e内容\u003c/h2\u003e\n\u003ch3 id=\"1-确定角色定义\"\u003e1. 确定角色定义\u003c/h3\u003e\n\u003cp\u003e明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e具体的职业身份（如：高级软件架构师、产品经理、数据分析师）\u003c/li\u003e\n\u003cli\u003e相关的专业背景和经验\u003c/li\u003e\n\u003cli\u003e工作场景和责任范围\u003c/li\u003e\n\u003cli\u003e与用户的关系定位\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 角色定义\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-确定核心目标\"\u003e2. 确定核心目标\u003c/h3\u003e\n\u003cp\u003e清晰描述希望 AI 完成的主要任务和期望达到的效果。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主要任务的具体描述\u003c/li\u003e\n\u003cli\u003e预期的输出结果\u003c/li\u003e\n\u003cli\u003e成功的衡量标准\u003c/li\u003e\n\u003cli\u003e目标用户和使用场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 核心目标\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"3-确定关键规则\"\u003e3. 确定关键规则\u003c/h3\u003e\n\u003cp\u003e设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e约束AI 的行为\u003c/li\u003e\n\u003cli\u003e内容的准确性标准\u003c/li\u003e\n\u003cli\u003e禁止的行为或内容\u003c/li\u003e\n\u003cli\u003e特殊情况的处理方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 关键规则\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **防简化要求**：严格遵循 \u003cspan style=\"color:#e6db74\"\u003e`./anti-simplification-rules.md`\u003c/span\u003e 中的防简化规则，绝对禁止简化、概述、总结原始需求内容\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"4-确定执行流程\"\u003e4. 确定执行流程\u003c/h3\u003e\n\u003cp\u003e定义 AI 处理任务的具体步骤和逻辑顺序。\u003c/p\u003e","title":"如何写出高质量的 Prompt"},{"content":"最近试用了下 augment 进行一些需求开发，感觉相比 cursor 还是解决了一些问题，挺好的进行分享下\n上下文机制 如何进行跨仓库开发，以前使用 cursor 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。 通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\n工具 另外一个比较好的点是 augment 提供了一些工具配置，可以一键进行安装使用\n任务规划 提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用 同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\n图表展示 不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好 提示词优化 可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用 ","permalink":"https://genluo.github.io/my-blog/posts/augment/","summary":"\u003cp\u003e最近试用了下 \u003ccode\u003eaugment\u003c/code\u003e 进行一些需求开发，感觉相比 \u003ccode\u003ecursor\u003c/code\u003e 还是解决了一些问题，挺好的进行分享下\u003c/p\u003e\n\u003ch2 id=\"上下文机制\"\u003e上下文机制\u003c/h2\u003e\n\u003cp\u003e如何进行跨仓库开发，以前使用 \u003ccode\u003ecursor\u003c/code\u003e 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\u003c/p\u003e\n\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\n\u003cp\u003e另外一个比较好的点是 \u003ccode\u003eaugment\u003c/code\u003e 提供了一些工具配置，可以一键进行安装使用\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image1.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"任务规划\"\u003e任务规划\u003c/h2\u003e\n\u003cp\u003e提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\u003c/p\u003e\n\u003ch2 id=\"图表展示\"\u003e图表展示\u003c/h2\u003e\n\u003cp\u003e不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image3.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"提示词优化\"\u003e提示词优化\u003c/h2\u003e\n\u003cp\u003e可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-2.png\"\u003e\u003c/p\u003e","title":"Augment 试用"},{"content":"状态机概述 状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\n核心概念 状态（State）：系统可能处于的一种情况或模式。 事件（Event）：触发状态转换的信号或动作。 转换（Transition）：定义从一个状态到另一个状态的规则。 回调（Callback）：状态转换时执行的逻辑。 应用场景 状态机在以下场景中特别有用：\n游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。 UI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。 工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。 协议实现：网络协议的状态管理（连接中、已连接、断开连接）。 动画控制：管理动画序列和转换。 基本用法 // 定义状态和事件类型 type State = \u0026#39;idle\u0026#39; | \u0026#39;running\u0026#39; | \u0026#39;paused\u0026#39; | \u0026#39;stopped\u0026#39;; type Event = \u0026#39;START\u0026#39; | \u0026#39;PAUSE\u0026#39; | \u0026#39;RESUME\u0026#39; | \u0026#39;STOP\u0026#39;; // 创建状态机实例 const sm = new StateMachine\u0026lt;State, Event\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;PAUSE\u0026#39;, \u0026#39;paused\u0026#39;), t(\u0026#39;paused\u0026#39;, \u0026#39;RESUME\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;), ]); // 触发状态转换 await sm.dispatch(\u0026#39;START\u0026#39;); // idle -\u0026gt; running console.log(sm.getState()); // \u0026#39;running\u0026#39; 高级特性 全局事件（ANY_STATE） 使用 ANY_STATE 符号定义可从任意状态触发的转换：\n// RESET 事件可从任何状态回到 idle 状态 sm.addTransitions([ t(ANY_STATE, \u0026#39;RESET\u0026#39;, \u0026#39;idle\u0026#39;, resetCallback) ]); 状态查询和预测 // 检查当前状态是否可以接收特定事件 if (sm.can(\u0026#39;PAUSE\u0026#39;)) { // 可以执行暂停操作 } // 获取事件触发后的下一个状态 const nextState = sm.getNextState(\u0026#39;STOP\u0026#39;); // \u0026#39;stopped\u0026#39; // 检查当前是否为终止状态（没有可用的出站转换） if (sm.isFinal()) { // 到达终止状态 } 子状态机 子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\n// 创建子状态机 const subMachine = new StateMachine\u0026lt;SubState, SubEvent\u0026gt;(\u0026#39;subIdle\u0026#39;, [ t(\u0026#39;subIdle\u0026#39;, \u0026#39;SUB_START\u0026#39;, \u0026#39;subRunning\u0026#39;), t(\u0026#39;subRunning\u0026#39;, \u0026#39;SUB_STOP\u0026#39;, \u0026#39;subStopped\u0026#39;) ]); // 创建主状态机 const mainMachine = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;) ]); // 将子状态机附加到主状态机的特定状态 mainMachine.addSubStateMachine(\u0026#39;running\u0026#39;, subMachine); 核心设计问题 状态切换回掉的处理 每次派发事件，状态机会立即进行响应，更新新的状态 针对事件切换回调函数执行，不会卡住状态机的状态 极端情况下，存在多个状态回调函数同时在执行的情况 子状态机的生命周期 当主状态机进入子状态时，子状态机被激活 子状态机可以处理自己的事件和状态转换。 当主状态机离开子状态时，子状态机被自动重置（reset） 子状态机只有在父状态机处于激活状态时才能接收事件 实际应用示例 游戏角色控制 graph TD Standing[Standing] --\u0026gt; |WALK| Walking[Walking] Walking --\u0026gt; |STOP| Standing Standing --\u0026gt; |JUMP| Jumping[Jumping] Walking --\u0026gt; |JUMP| Jumping Jumping --\u0026gt; |LAND| Standing Standing --\u0026gt; |ATTACK| Attacking[Attacking] Walking --\u0026gt; |ATTACK| Attacking Jumping --\u0026gt; |ATTACK| Attacking Attacking --\u0026gt; |STOP| Standing type CharacterState = \u0026#39;standing\u0026#39; | \u0026#39;walking\u0026#39; | \u0026#39;jumping\u0026#39; | \u0026#39;attacking\u0026#39;; type CharacterEvent = \u0026#39;WALK\u0026#39; | \u0026#39;JUMP\u0026#39; | \u0026#39;ATTACK\u0026#39; | \u0026#39;STOP\u0026#39; | \u0026#39;LAND\u0026#39;; // 创建角色状态机 const character = new StateMachine\u0026lt;CharacterState, CharacterEvent\u0026gt;(\u0026#39;standing\u0026#39;, [ t(\u0026#39;standing\u0026#39;, \u0026#39;WALK\u0026#39;, \u0026#39;walking\u0026#39;, startWalkAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopWalkAnimation), t(\u0026#39;standing\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;jumping\u0026#39;, \u0026#39;LAND\u0026#39;, \u0026#39;standing\u0026#39;, landAnimation), t(ANY_STATE, \u0026#39;ATTACK\u0026#39;, \u0026#39;attacking\u0026#39;, attackAnimation), t(\u0026#39;attacking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopAttackAnimation), ]); UI 组件状态管理 graph TD Normal[Normal] --\u0026gt; |MOUSE_ENTER| Hover[Hover] Hover --\u0026gt; |MOUSE_LEAVE| Normal Hover --\u0026gt; |MOUSE_DOWN| Pressed[Pressed] Pressed --\u0026gt; |MOUSE_UP| Hover Pressed --\u0026gt; |MOUSE_LEAVE| Normal Normal --\u0026gt; |DISABLE| Disabled[Disabled] Hover --\u0026gt; |DISABLE| Disabled Pressed --\u0026gt; |DISABLE| Disabled Disabled --\u0026gt; |ENABLE| Normal type ButtonState = \u0026#39;normal\u0026#39; | \u0026#39;hover\u0026#39; | \u0026#39;pressed\u0026#39; | \u0026#39;disabled\u0026#39;; type ButtonEvent = \u0026#39;MOUSE_ENTER\u0026#39; | \u0026#39;MOUSE_LEAVE\u0026#39; | \u0026#39;MOUSE_DOWN\u0026#39; | \u0026#39;MOUSE_UP\u0026#39; | \u0026#39;DISABLE\u0026#39; | \u0026#39;ENABLE\u0026#39;; // 创建按钮状态机 const button = new StateMachine\u0026lt;ButtonState, ButtonEvent\u0026gt;(\u0026#39;normal\u0026#39;, [ t(\u0026#39;normal\u0026#39;, \u0026#39;MOUSE_ENTER\u0026#39;, \u0026#39;hover\u0026#39;, showHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_DOWN\u0026#39;, \u0026#39;pressed\u0026#39;, showPressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_UP\u0026#39;, \u0026#39;hover\u0026#39;, removePressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeAllEffects), t(ANY_STATE, \u0026#39;DISABLE\u0026#39;, \u0026#39;disabled\u0026#39;, disableButton), t(\u0026#39;disabled\u0026#39;, \u0026#39;ENABLE\u0026#39;, \u0026#39;normal\u0026#39;, enableButton), ]); 游戏角色管理系统 这个例子展示了如何使用嵌套状态机来管理游戏角色的复杂状态。主状态机处理角色的生命周期（闲置、活动、死亡），而子状态机则专注于角色在\u0026quot;活动\u0026quot;状态下可以执行的各种行为\nstateDiagram-v2 [*] --\u0026gt; idle idle --\u0026gt; active: ACTIVATE active --\u0026gt; idle: REST active --\u0026gt; dead: DIE dead --\u0026gt; idle: RESPAWN state active { [*] --\u0026gt; moving moving --\u0026gt; fighting: ENGAGE fighting --\u0026gt; moving: DISENGAGE moving --\u0026gt; interacting: INTERACT interacting --\u0026gt; moving: FINISH } // 主状态机状态和事件 type MainState = \u0026#39;idle\u0026#39; | \u0026#39;active\u0026#39; | \u0026#39;dead\u0026#39;; type MainEvent = \u0026#39;ACTIVATE\u0026#39; | \u0026#39;REST\u0026#39; | \u0026#39;DIE\u0026#39; | \u0026#39;RESPAWN\u0026#39;; // 子状态机状态和事件 type ActiveState = \u0026#39;moving\u0026#39; | \u0026#39;fighting\u0026#39; | \u0026#39;interacting\u0026#39;; type ActiveEvent = \u0026#39;ENGAGE\u0026#39; | \u0026#39;DISENGAGE\u0026#39; | \u0026#39;INTERACT\u0026#39; | \u0026#39;FINISH\u0026#39;; // 创建子状态机（角色活动状态） const activeStateMachine = new StateMachine\u0026lt;ActiveState, ActiveEvent\u0026gt;(\u0026#39;moving\u0026#39;, [ t(\u0026#39;moving\u0026#39;, \u0026#39;ENGAGE\u0026#39;, \u0026#39;fighting\u0026#39;, startCombatSystem), t(\u0026#39;fighting\u0026#39;, \u0026#39;DISENGAGE\u0026#39;, \u0026#39;moving\u0026#39;, endCombatSystem), t(\u0026#39;moving\u0026#39;, \u0026#39;INTERACT\u0026#39;, \u0026#39;interacting\u0026#39;, startInteraction), t(\u0026#39;interacting\u0026#39;, \u0026#39;FINISH\u0026#39;, \u0026#39;moving\u0026#39;, endInteraction) ]); // 创建主状态机（角色生命周期） const characterManager = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;ACTIVATE\u0026#39;, \u0026#39;active\u0026#39;, activateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;REST\u0026#39;, \u0026#39;idle\u0026#39;, deactivateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;DIE\u0026#39;, \u0026#39;dead\u0026#39;, handleDeath), t(\u0026#39;dead\u0026#39;, \u0026#39;RESPAWN\u0026#39;, \u0026#39;idle\u0026#39;, handleRespawn) ]); // 将活动状态子状态机附加到主状态机的\u0026#34;active\u0026#34;状态 characterManager.addSubStateMachine(\u0026#39;active\u0026#39;, activeStateMachine); // 使用示例 await characterManager.dispatch(\u0026#39;ACTIVATE\u0026#39;); // 进入active状态，子状态机激活 await activeStateMachine.dispatch(\u0026#39;ENGAGE\u0026#39;); // 切换到战斗状态 await activeStateMachine.dispatch(\u0026#39;DISENGAGE\u0026#39;); // 返回移动状态 await characterManager.dispatch(\u0026#39;REST\u0026#39;); // 回到idle状态，子状态机重置 结合 和UI结合 您的浏览器不支持视频标签。 和AI结合 您的浏览器不支持视频标签。 总结 状态机提供了一种清晰、直观的方式来管理复杂系统的状态转换逻辑。通过明确定义状态、事件和转换规则，可以有效避免状态管理中的混乱和错误。子状态机机制进一步增强了状态机的能力，使其能够处理更复杂的分层状态结构。无论是游戏开发、UI交互还是业务流程管理，状态机都是一种强大而灵活的解决方案。\n","permalink":"https://genluo.github.io/my-blog/posts/statemachine/","summary":"\u003ch2 id=\"状态机概述\"\u003e状态机概述\u003c/h2\u003e\n\u003cp\u003e状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\u003c/p\u003e\n\u003ch2 id=\"核心概念\"\u003e核心概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e状态（State）\u003c/strong\u003e：系统可能处于的一种情况或模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e事件（Event）\u003c/strong\u003e：触发状态转换的信号或动作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e转换（Transition）\u003c/strong\u003e：定义从一个状态到另一个状态的规则。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回调（Callback）\u003c/strong\u003e：状态转换时执行的逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"应用场景\"\u003e应用场景\u003c/h2\u003e\n\u003cp\u003e状态机在以下场景中特别有用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。\u003c/li\u003e\n\u003cli\u003eUI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。\u003c/li\u003e\n\u003cli\u003e工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。\u003c/li\u003e\n\u003cli\u003e协议实现：网络协议的状态管理（连接中、已连接、断开连接）。\u003c/li\u003e\n\u003cli\u003e动画控制：管理动画序列和转换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本用法\"\u003e基本用法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义状态和事件类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 创建状态机实例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStateMachine\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003eState\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e\u0026gt;(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 触发状态转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003edispatch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// idle -\u0026gt; running\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetState\u003c/span\u003e());  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;running\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"高级特性\"\u003e高级特性\u003c/h2\u003e\n\u003ch3 id=\"全局事件any_state\"\u003e全局事件（ANY_STATE）\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eANY_STATE\u003c/code\u003e 符号定义可从任意状态触发的转换：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// RESET 事件可从任何状态回到 idle 状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddTransitions\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eANY_STATE\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eresetCallback\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"状态查询和预测\"\u003e状态查询和预测\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前状态是否可以接收特定事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecan\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 可以执行暂停操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 获取事件触发后的下一个状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enextState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetNextState\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;stopped\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前是否为终止状态（没有可用的出站转换）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eisFinal\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 到达终止状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"子状态机\"\u003e子状态机\u003c/h3\u003e\n\u003cp\u003e子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\u003c/p\u003e","title":"StateMachine"},{"content":"关于我 做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出性能强劲，用户体验优异，能产生业务价值的产品\n常用工具箱 语言：TypeScript、C++ 框架：React、NestJs 运行时：Node.js、Chrome/浏览器、visionOS 标准：webGPU、WebAssembly、 历史项目 淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频） 淘宝3D引擎对应的相关产品 端渲染和云渲染协同切换（webRTC、追帧算法） 引擎Binding技术方案落地（quickJS、wasm） 引擎对应的3D编辑器（编辑器、节点编辑、AI Agent） 专利 一种基于端云协同的三维场景加载及渲染技术（2024-01-12） 全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17） 联系方式 邮箱：isgenluo@gmail.com GitHub：我的GitHub主页 ","permalink":"https://genluo.github.io/my-blog/about/","summary":"\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cp\u003e做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出\u003cstrong\u003e性能强劲\u003c/strong\u003e，用户\u003cstrong\u003e体验优异\u003c/strong\u003e，能产生业务价值的产品\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-6.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"常用工具箱\"\u003e常用工具箱\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e语言：TypeScript、C++\u003c/li\u003e\n\u003cli\u003e框架：React、NestJs\u003c/li\u003e\n\u003cli\u003e运行时：Node.js、Chrome/浏览器、visionOS\u003c/li\u003e\n\u003cli\u003e标准：webGPU、WebAssembly、\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"历史项目\"\u003e历史项目\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频）\u003c/li\u003e\n\u003cli\u003e淘宝3D引擎对应的相关产品\n\u003cul\u003e\n\u003cli\u003e端渲染和云渲染协同切换（webRTC、追帧算法）\u003c/li\u003e\n\u003cli\u003e引擎Binding技术方案落地（quickJS、wasm）\u003c/li\u003e\n\u003cli\u003e引擎对应的3D编辑器（编辑器、节点编辑、AI Agent）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"专利\"\u003e专利\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一种基于端云协同的三维场景加载及渲染技术（2024-01-12）\u003c/li\u003e\n\u003cli\u003e全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"联系方式\"\u003e联系方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e邮箱：\u003ca href=\"mailto:isgenluo@gmail.com\"\u003eisgenluo@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGitHub：\u003ca href=\"https://github.com/genluo\"\u003e我的GitHub主页\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"关于我"}]