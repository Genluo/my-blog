[{"content":"ReaderWriterQueue 是一个高性能的 C++无锁队列实现，专为单生产者-单消费者（SPSC）场景设计。\n无锁设计：完全无锁实现，enqueue 和 dequeue 操作都是 O(1)时间复杂度 高性能：在 x86 架构上，内存屏障编译为无操作指令，性能极佳 C++11 兼容：支持移动语义，减少不必要的拷贝 泛型模板：使用模版支持任意类型的元素，类似 std::queue 内存高效：预分配连续内存块，提供 try_enqueue 保证不分配内存 阻塞版本：提供 BlockingReaderWriterQueue 支持 wait_dequeue 操作 适用于需要在两个线程间高效传递数据的场景，如生产者-消费者模式、异步任务处理等。仅需包含头文件即可使用，无需额外依赖\n核心问题 1. 整体思路 代码中主要包含两个部分，一个是队列链表，这个链表中存储很多的 block，每个 block 内部实现又是一个链表，这个链表，有读写两个指针，可以存放多个线程共享的元素\n2. 内存中结构 存储的数据分为两部分，一部分是 Block 中属性数据+内存对其\nauto size = sizeof(Block) + std::alignment_of\u0026lt;Block\u0026gt;::value - 1; 另一部分则是需要存储的具体数据：\nsize += sizeof(T) * capacity + std::alignment_of\u0026lt;T\u0026gt;::value - 1; 针对申请的内容，实际分配内存进行对其\nauto newBlockRaw = static_cast\u0026lt;char *\u0026gt;(std::malloc(size)); auto newBlockAligned = align_for\u0026lt;Block\u0026gt;(newBlockRaw); auto newBlockData = align_for\u0026lt;T\u0026gt;(newBlockAligned + sizeof(Block)); template \u0026lt;typename U\u0026gt; static AE_FORCEINLINE char *align_for(char *ptr) AE_NO_TSAN { const std::size_t alignment = std::alignment_of\u0026lt;U\u0026gt;::value; return ptr + (alignment - (reinterpret_cast\u0026lt;std::uintptr_t\u0026gt;(ptr) % alignment)) % alignment; } 为什么这个过程中需要内存对其，可以看下下面的问题部分\n3. 如何使用 测试 单元测试 稳定性测试 CRTP 设计模式 通过 CRTP，基类可以调用派生类的方法，实现了静态多态，在这个项目中是这样使用\n核心思想 \u0026ldquo;派生类告诉基类自己是谁\u0026rdquo; - 通过模板参数传递自身类型 静态多态 - 编译时确定调用关系，无运行时开销 类型安全 - 编译时检查，避免类型错误 优势 零运行时开销，相比虚函数性能强大很多（不使用虚函数表） 编译时类型检查（虚函数运行时多态，无法完全被优化） 代码复用（可以使用基类功能，派生类只需要实现特定的功能） 示例 基础示例 // CRTP 方法 template \u0026lt;typename Derived\u0026gt; class CRTPBase { public: int calculate() { return static_cast\u0026lt;Derived *\u0026gt;(this)-\u0026gt;calculate_impl(); } }; class CRTPDerived : public CRTPBase\u0026lt;CRTPDerived\u0026gt; { public: int calculate_impl() { return 42; } }; 测试用例 #define REGISTER_TEST(testName) registerTest(#testName, \u0026amp;subclass_t::testName) template \u0026lt;typename TSubclass\u0026gt; class TestClass { public: typedef TSubclass subclass_t; void registerTest(const char *name, bool (subclass_t::*method)()); }; class Test : public TestClass\u0026lt;Test\u0026gt; { public: Test() { REGISTER_TEST(test1); REGISTER_TEST(test2); } bool test1(); bool test2(); }; 测试过程中预定义宏 我来为您整理一个完整的 C/C++ 预定义宏表格：\nC/C++ 预定义宏表 标准预定义宏 宏名 描述 类型 示例值 __LINE__ 当前行号 整数 42 __FILE__ 当前文件名 字符串 \u0026quot;main.cpp\u0026quot; __DATE__ 编译日期 字符串 \u0026quot;Aug 20 2025\u0026quot; __TIME__ 编译时间 字符串 \u0026quot;14:30:25\u0026quot; __TIMESTAMP__ 文件最后修改时间 字符串 \u0026quot;Mon Aug 20 14:30:25 2025\u0026quot; C++ 函数/作用域相关宏 宏名 描述 类型 示例值 __func__ 当前函数名 (C99/C++11) 字符串 \u0026quot;main\u0026quot; __FUNCTION__ 当前函数名 (GCC 扩展) 字符串 \u0026quot;main\u0026quot; __PRETTY_FUNCTION__ 完整函数签名 (GCC) 字符串 \u0026quot;int main(int, char**)\u0026quot; 标准版本宏 宏名 描述 类型 示例值 __STDC__ 符合标准 C 整数 1 __STDC_VERSION__ C 标准版本 整数 201112L (C11) __cplusplus C++标准版本 整数 201703L (C++17) __STDC_HOSTED__ 是否为宿主环境 整数 1 编译器特定宏 宏名 描述 编译器 示例值 __GNUC__ GCC 主版本号 GCC 11 __GNUC_MINOR__ GCC 次版本号 GCC 3 __clang__ Clang 编译器 Clang 1 _MSC_VER MSVC 版本 MSVC 1930 __INTEL_COMPILER Intel 编译器版本 ICC 2021 平台/架构宏 宏名 描述 平台 示例值 _WIN32 Windows (32/64 位) Windows 1 _WIN64 Windows 64 位 Windows 1 __linux__ Linux 系统 Linux 1 __APPLE__ Apple 平台 macOS/iOS 1 __unix__ Unix 系统 Unix-like 1 __x86_64__ x86-64 架构 64 位 x86 1 __aarch64__ ARM64 架构 ARM64 1 调试相关宏 宏名 描述 类型 备注 NDEBUG 发布模式 整数/未定义 定义时禁用 assert _DEBUG 调试模式 整数 MSVC 特定 DEBUG 调试模式 整数 非标准 特殊用途宏 宏名 描述 类型 用途 __COUNTER__ 递增计数器 整数 每次使用自增 __BASE_FILE__ 主源文件名 字符串 编译单元的基础文件 __INCLUDE_LEVEL__ 包含层级 整数 嵌套包含深度 特性检测宏 (C++11+) 宏名 描述 类型 示例值 __has_include 检查头文件支持 函数宏 __has_include __has_cpp_attribute 检查 C++属性支持 函数宏 __has_cpp_attribute(nodiscard) 数值类型相关宏 宏名 描述 类型 示例值 __SIZEOF_INT__ int 类型字节数 整数 4 __SIZEOF_POINTER__ 指针字节数 整数 8 __CHAR_BIT__ char 位数 整数 8 性能 benchmarks SIMD 优化 问题 1. false sharing 问题 伪共享是指两个或多个 CPU 核心频繁访问同一缓存行中的不同数据，导致缓存行在不同核心之间不断传递，造成性能下降的现象。\n缓存行（64字节）：[变量A][变量B][其他数据...] ↑ ↑ 核心1访问 核心2访问 虽然核心 1 只访问变量 A，核心 2 只访问变量 B，但因为它们在同一缓存行中：\n核心 1 修改变量 A → 整个缓存行失效 核心 2 访问变量 B → 需要重新加载缓存行 核心 2 修改变量 B → 核心 1 的缓存行失效 核心 1 再次访问变量 A → 又需要重新加载\n避免伪共享 使用 cachelineFiller0 将 front 和 tail 分隔到不同缓存行，生产者线程主要访问的 tail 和消费者线程主要访问的 front 不会相互干扰\nstruct Block { weak_atomic\u0026lt;size_t\u0026gt; front; // 消费者主要访问 size_t localTail; // 消费者拥有 // 缓存行填充 - 确保下面的变量在不同缓存行 char cachelineFiller0[MOODYCAMEL_CACHE_LINE_SIZE - sizeof(weak_atomic\u0026lt;size_t\u0026gt;) - sizeof(size_t)]; weak_atomic\u0026lt;size_t\u0026gt; tail; // 生产者主要访问 size_t localFront; // 生产者拥有 // 再次填充 char cachelineFiller1[MOODYCAMEL_CACHE_LINE_SIZE - sizeof(weak_atomic\u0026lt;size_t\u0026gt;) - sizeof(size_t)]; weak_atomic\u0026lt;Block*\u0026gt; next; // ... }; 2. 编译器重排序问题 指令重排序 内粗访问重新排序 循环优化重排序 问题示例 数据竞争：data 和 ready 没有同步保护，同时被多个线程访问 内存重排序：编译器/CPU 可能重排序指令，ready = true 可能在 data = 42 之前执行 可见性问题：一个线程的写操作可能不会立即对另一个线程可见 编译器可能将 producer 中的指令重排序为： // ready = true; // 被提前！ // data = 42;// 被延后！ // 这会导致消费者读取到错误的 data 值\n#include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; int data = 0; bool ready = false; // 线程1：生产者 void producer() { data = 42;// Step 1 ready = true; // Step 2 } // 线程2：消费者 void consumer() { while (!ready) { // 等待 } std::cout \u0026lt;\u0026lt; \u0026#34;Data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; // 期望输出42 } 解决编译器重排序问题 使用 volatile volatile int flag = 0; int data = 0; void producer() { data = 42; flag = 1; // volatile 防止重排序 } void consumer() { while (flag ==0) { // volatile 防止优化 // 等待 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); } 使用 内存屏障 #include \u0026lt;atomic\u0026gt; int data = 0; bool ready = false; void producer() { data = 42; std::atomic_signal_fence(std::memory_order_release); // 编译器屏障 ready = true; } void consumer() { while (!ready) {std::atomic_signal_fence(std::memory_order_acquire); // 编译器屏障 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); } 使用原子操作 #include \u0026lt;atomic\u0026gt; int data = 0; std::atomic\u0026lt;bool\u0026gt; ready{false}; void producer() { data = 42; ready.store(true, std::memory_order_release); // 防止重排序 } void consumer() { while (!ready.load(std::memory_order_acquire)) { // 等待 } printf(\u0026#34;Data: %d\\n\u0026#34;, data); // 保证读取到正确值 } 编译器重排序\u0026amp;CPU 重排序 特性 编译器重排序 CPU 重排序 发生时机 编译时 运行时 影响范围 所有平台 特定 CPU 架构 防护方法 编译器屏障 内存屏障指令 性能影响 编译时优化 运行时开销 实践 单线程通常不用关心，但是多线程需要关系这个问题 3. 信号量 在 Apple iOS and OSX 平台上选用 Mach 信号量的原因： http://lists.apple.com/archives/darwin-kernel/2009/Apr/msg00010.html 4. 内存对齐 内存对齐是指数据在内存中的存储位置必须是某个特定数值的倍数。例如，一个 4 字节的整数可能需要存储在地址为 4 的倍数的位置上。\n对齐的数据可以一次读取，不对其可能需要多次 对齐的数据更容易命中缓存 5. 多线程数据竞争和同步问题 特性/机制 互斥锁 (Mutex) 读写锁 (Shared Mutex) 原子操作 (Atomic Operations) 并发性能 较差，锁竞争时性能下降 较好，读多写少时效果显著 非常好，几乎没有开销 写操作性能 好 差，写操作时锁竞争严重 非常好，原子操作通常不需要锁 读操作性能 较差，阻塞等待锁 好，允许多个读线程并行 非常好，读操作不需要锁 复杂度 低，易于理解和使用 中，管理读写锁和线程竞争 高，只有简单的操作可以用原子操作 适用场景 一般适用于少数临界区的保护 适合读多写少的场景 适合对单个变量的高效操作 开销 高，特别是在锁竞争严重时 中等，读写锁竞争时会有开销 低，原子操作无需阻塞 参考 Readerwriterqueue ","permalink":"https://genluo.github.io/my-blog/posts/readerwriterqueue/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/cameron314/readerwriterqueue\"\u003eReaderWriterQueue\u003c/a\u003e 是一个高性能的 C++无锁队列实现，专为单生产者-单消费者（SPSC）场景设计。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无锁设计：完全无锁实现，enqueue 和 dequeue 操作都是 O(1)时间复杂度\u003c/li\u003e\n\u003cli\u003e高性能：在 x86 架构上，内存屏障编译为无操作指令，性能极佳\u003c/li\u003e\n\u003cli\u003eC++11 兼容：支持移动语义，减少不必要的拷贝\u003c/li\u003e\n\u003cli\u003e泛型模板：使用模版支持任意类型的元素，类似 std::queue\u003c/li\u003e\n\u003cli\u003e内存高效：预分配连续内存块，提供 try_enqueue 保证不分配内存\u003c/li\u003e\n\u003cli\u003e阻塞版本：提供 BlockingReaderWriterQueue 支持 wait_dequeue 操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e适用于需要在两个线程间高效传递数据的场景，如生产者-消费者模式、异步任务处理等。仅需包含头文件即可使用，无需额外依赖\u003c/p\u003e\n\u003ch2 id=\"核心问题\"\u003e核心问题\u003c/h2\u003e\n\u003ch3 id=\"1-整体思路\"\u003e1. 整体思路\u003c/h3\u003e\n\u003cp\u003e代码中主要包含两个部分，一个是队列链表，这个链表中存储很多的 block，每个 block 内部实现又是一个链表，这个链表，有读写两个指针，可以存放多个线程共享的元素\u003c/p\u003e\n\u003ch3 id=\"2-内存中结构\"\u003e2. 内存中结构\u003c/h3\u003e\n\u003cp\u003e存储的数据分为两部分，一部分是 Block 中属性数据+内存对其\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e size \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(Block) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBlock\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e另一部分则是需要存储的具体数据：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esize \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(T) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e capacity \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e针对申请的内容，实际分配内存进行对其\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockRaw \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e(std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003emalloc(size));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockAligned \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e align_for\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBlock\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(newBlockRaw);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e newBlockData \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e align_for\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(newBlockAligned \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(Block));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e U\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e AE_FORCEINLINE \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ealign_for(\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eptr) AE_NO_TSAN {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003esize_t alignment \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ealignment_of\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eU\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003evalue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ptr \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          (alignment \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ereinterpret_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003estd\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003euintptr_t\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(ptr) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e alignment)) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              alignment;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为什么这个过程中需要内存对其，可以看下下面的问题部分\u003c/p\u003e","title":"Readerwriterqueue 源代码阅读"},{"content":"基本配置 一般来说，vscode 中开发 c++ 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 clangd ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\n基础配置 如果使用 cmake 进行开发，可以添加编译参数 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 来生成 clangd 需要的 compile_commands.json 来索引整个项目的源文件\n通过 cmake 进行配置生成，包含 bear 工具介绍 generates a compilation database for clang tooling.\n如果使用的是其他的构建系统，没有使用 cmake 可以使用这个工具，生成对应的 compile_commands.json\nbear -- make 重启服务之后，可以正常进行跳转\n","permalink":"https://genluo.github.io/my-blog/posts/vscode+clangd/","summary":"\u003ch2 id=\"基本配置\"\u003e基本配置\u003c/h2\u003e\n\u003cp\u003e一般来说，\u003ccode\u003evscode\u003c/code\u003e 中开发 \u003ccode\u003ec++\u003c/code\u003e 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 \u003ccode\u003eclangd\u003c/code\u003e ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\u003c/p\u003e\n\u003ch3 id=\"基础配置\"\u003e基础配置\u003c/h3\u003e\n\u003cp\u003e如果使用 \u003ccode\u003ecmake\u003c/code\u003e 进行开发，可以添加编译参数 \u003ccode\u003e-DCMAKE_EXPORT_COMPILE_COMMANDS=ON\u003c/code\u003e 来生成 \u003ccode\u003eclangd\u003c/code\u003e 需要的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e 来索引整个项目的源文件\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ecmake\u003c/code\u003e 进行配置生成，包含\n\u003cimg loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-3.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"bear-工具介绍\"\u003e\u003ca href=\"https://github.com/rizsotto/Bear\"\u003ebear\u003c/a\u003e 工具介绍\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003egenerates a compilation database for clang tooling.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e如果使用的是其他的构建系统，没有使用 \u003ccode\u003ecmake\u003c/code\u003e 可以使用这个工具，生成对应的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebear -- make\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e重启服务之后，可以正常进行跳转\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-5.png\"\u003e\u003c/p\u003e","title":"Vscode+clangd"},{"content":"整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\n要点 内容需要详细，不要概括笼统，月具体越好 让模型充当一个角色，让其更加专业和明确 使用分割符来区分输出的不同部分 指定任务完成的步骤，将复杂任务简化 提供示例，给模型进行参考 指定输出长度 内容 1. 确定角色定义 明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\n要点：\n具体的职业身份（如：高级软件架构师、产品经理、数据分析师） 相关的专业背景和经验 工作场景和责任范围 与用户的关系定位 示例：\n## 角色定义 你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。 2. 确定核心目标 清晰描述希望 AI 完成的主要任务和期望达到的效果。\n要点：\n主要任务的具体描述 预期的输出结果 成功的衡量标准 目标用户和使用场景 示例：\n## 核心目标 - **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档 3. 确定关键规则 设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\n要点：\n约束AI 的行为 内容的准确性标准 禁止的行为或内容 特殊情况的处理方式 示例：\n## 关键规则 - **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节 - **防简化要求**：严格遵循 `./anti-simplification-rules.md` 中的防简化规则，绝对禁止简化、概述、总结原始需求内容 4. 确定执行流程 定义 AI 处理任务的具体步骤和逻辑顺序。\n要点：\n分析问题的步骤 信息收集和处理流程 决策和推理过程 输出生成的顺序 示例：\n## 拆解执行流程 ### 任务1：知识了解 **目标**：深入学习XXX互动游戏框架的核心知识和互动基座架构 **执行清单**： 1. **阅读xxxx文档**： - 仔细阅读 `.xxx.md` 文件 - 重点理解xxxx的定义和概念、功能 2. **阅读xxxx模型文档**： - 仔细阅读 `.xxxx.md` 文件 - 重点理解xxx模型的核心概念、数据结构和业务流程 - 识别关键实体和它们之间的关系 3. **阅读互动基座架构文档**： - 仔细阅读 `.xxxx.md` 文件 - 理解互动基座的整体架构设计、各层职责和模块划分 - 掌握技术实现细节和集成方式 4. **知识整合分析**： - 分析两个文档中的关键信息点 - 建立xxxx模型与互动基座架构之间的映射关系 - 识别业务概念到技术实现的转换路径 ### 任务2：环境准备 **目标**：建立标准化的文档目录结构 **执行清单**： 1. ✅ 检查并创建根目录：`./docs` 2. ✅ 检查并创建需求目录：`./docs/requirements` 3. ✅ 检查并创建子需求目录：`./docs/sub_requirements` 4. ✅ 检查并创建功能设计目录：`./docs/function_designs` 5. ✅ 验证原始需求文件存在：`./docs/requirements/{需求ID}.md` ### 任务3：需求分析与拆解 **目标**：基于xxxx模型进行系统性需求分析 **输出**：需求拆解分析报告 ### 任务4：子需求文档生成 **目标**：创建结构化的子需求文档 **文档规范**： **输出**：完整的子需求文档集合 ### 任务5：一致性保证 **目标**：确保所有文档间的技术一致性 **输出**：技术一致性报告 5. 确定输出模版 规范化输出格式，确保信息的结构化和易读性。\n要点：\n固定的输出结构 各部分的内容要求 格式化规范 示例和模板 示例：\n## 需求文档模版 整体务必遵循 .xxx-split-template.md 模版的格式 输出模版 # [产品包名称]技术方案 \u0026gt; **使用说明：** 本模板适用于XXX互动游戏框架的产品包技术方案设计，请根据实际情况填写各个章节内容。带有 `[占位符]` 的内容需要替换为具体信息。 ## 概述 \u0026gt; **填写指导：** 用1-2句话简洁描述产品包的核心定位和技术实现方式，说明其基于IGF框架的扩展方案。 [产品包名称]是[目标活动/业务场景]的[核心功能定位]，负责[主要功能1]、[主要功能2]、[主要功能3]等功能。本技术方案基于 xxxx 基座的 [骨架名称] 骨架进行扩展实现，采用 IGF [框架类型]框架实现[核心玩法/业务逻辑]。 .... 大模型参数 Temperature：简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。 Top_p：同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。 Max Length：您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。 Stop Sequences：stop sequence 是一个字符串，可以阻止模型生成 token，指定 stop sequences 是控制大模型响应长度和结构的另一种方法。例如，您可以通过添加 “11” 作为 stop sequence 来告诉模型生成不超过 10 个项的列表。 Frequency Penalty：frequency penalty 是对下一个生成的 token 进行惩罚，这个惩罚和 token 在响应和提示中已出现的次数成比例， frequency penalty 越高，某个词再次出现的可能性就越小，这个设置通过给 重复数量多的 Token 设置更高的惩罚来减少响应中单词的重复。 Presence Penalty：presence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。 参考 https://www.promptingguide.ai/zh ","permalink":"https://genluo.github.io/my-blog/posts/prompt/","summary":"\u003cp\u003e整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\u003c/p\u003e\n\u003ch2 id=\"要点\"\u003e要点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e内容需要详细，不要概括笼统，月具体越好\u003c/li\u003e\n\u003cli\u003e让模型充当一个角色，让其更加专业和明确\u003c/li\u003e\n\u003cli\u003e使用分割符来区分输出的不同部分\u003c/li\u003e\n\u003cli\u003e指定任务完成的步骤，将复杂任务简化\u003c/li\u003e\n\u003cli\u003e提供示例，给模型进行参考\u003c/li\u003e\n\u003cli\u003e指定输出长度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"内容\"\u003e内容\u003c/h2\u003e\n\u003ch3 id=\"1-确定角色定义\"\u003e1. 确定角色定义\u003c/h3\u003e\n\u003cp\u003e明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e具体的职业身份（如：高级软件架构师、产品经理、数据分析师）\u003c/li\u003e\n\u003cli\u003e相关的专业背景和经验\u003c/li\u003e\n\u003cli\u003e工作场景和责任范围\u003c/li\u003e\n\u003cli\u003e与用户的关系定位\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 角色定义\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-确定核心目标\"\u003e2. 确定核心目标\u003c/h3\u003e\n\u003cp\u003e清晰描述希望 AI 完成的主要任务和期望达到的效果。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主要任务的具体描述\u003c/li\u003e\n\u003cli\u003e预期的输出结果\u003c/li\u003e\n\u003cli\u003e成功的衡量标准\u003c/li\u003e\n\u003cli\u003e目标用户和使用场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 核心目标\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"3-确定关键规则\"\u003e3. 确定关键规则\u003c/h3\u003e\n\u003cp\u003e设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e约束AI 的行为\u003c/li\u003e\n\u003cli\u003e内容的准确性标准\u003c/li\u003e\n\u003cli\u003e禁止的行为或内容\u003c/li\u003e\n\u003cli\u003e特殊情况的处理方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 关键规则\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **防简化要求**：严格遵循 \u003cspan style=\"color:#e6db74\"\u003e`./anti-simplification-rules.md`\u003c/span\u003e 中的防简化规则，绝对禁止简化、概述、总结原始需求内容\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"4-确定执行流程\"\u003e4. 确定执行流程\u003c/h3\u003e\n\u003cp\u003e定义 AI 处理任务的具体步骤和逻辑顺序。\u003c/p\u003e","title":"如何写出高质量的 Prompt"},{"content":"最近试用了下 augment 进行一些需求开发，感觉相比 cursor 还是解决了一些问题，挺好的进行分享下\n上下文机制 如何进行跨仓库开发，以前使用 cursor 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。 通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\n工具 另外一个比较好的点是 augment 提供了一些工具配置，可以一键进行安装使用\n任务规划 提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用 同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\n图表展示 不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好 提示词优化 可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用 ","permalink":"https://genluo.github.io/my-blog/posts/augment/","summary":"\u003cp\u003e最近试用了下 \u003ccode\u003eaugment\u003c/code\u003e 进行一些需求开发，感觉相比 \u003ccode\u003ecursor\u003c/code\u003e 还是解决了一些问题，挺好的进行分享下\u003c/p\u003e\n\u003ch2 id=\"上下文机制\"\u003e上下文机制\u003c/h2\u003e\n\u003cp\u003e如何进行跨仓库开发，以前使用 \u003ccode\u003ecursor\u003c/code\u003e 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\u003c/p\u003e\n\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\n\u003cp\u003e另外一个比较好的点是 \u003ccode\u003eaugment\u003c/code\u003e 提供了一些工具配置，可以一键进行安装使用\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image1.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"任务规划\"\u003e任务规划\u003c/h2\u003e\n\u003cp\u003e提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\u003c/p\u003e\n\u003ch2 id=\"图表展示\"\u003e图表展示\u003c/h2\u003e\n\u003cp\u003e不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image3.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"提示词优化\"\u003e提示词优化\u003c/h2\u003e\n\u003cp\u003e可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-2.png\"\u003e\u003c/p\u003e","title":"Augment 试用"},{"content":"状态机概述 状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\n核心概念 状态（State）：系统可能处于的一种情况或模式。 事件（Event）：触发状态转换的信号或动作。 转换（Transition）：定义从一个状态到另一个状态的规则。 回调（Callback）：状态转换时执行的逻辑。 应用场景 状态机在以下场景中特别有用：\n游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。 UI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。 工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。 协议实现：网络协议的状态管理（连接中、已连接、断开连接）。 动画控制：管理动画序列和转换。 基本用法 // 定义状态和事件类型 type State = \u0026#39;idle\u0026#39; | \u0026#39;running\u0026#39; | \u0026#39;paused\u0026#39; | \u0026#39;stopped\u0026#39;; type Event = \u0026#39;START\u0026#39; | \u0026#39;PAUSE\u0026#39; | \u0026#39;RESUME\u0026#39; | \u0026#39;STOP\u0026#39;; // 创建状态机实例 const sm = new StateMachine\u0026lt;State, Event\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;PAUSE\u0026#39;, \u0026#39;paused\u0026#39;), t(\u0026#39;paused\u0026#39;, \u0026#39;RESUME\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;), ]); // 触发状态转换 await sm.dispatch(\u0026#39;START\u0026#39;); // idle -\u0026gt; running console.log(sm.getState()); // \u0026#39;running\u0026#39; 高级特性 全局事件（ANY_STATE） 使用 ANY_STATE 符号定义可从任意状态触发的转换：\n// RESET 事件可从任何状态回到 idle 状态 sm.addTransitions([ t(ANY_STATE, \u0026#39;RESET\u0026#39;, \u0026#39;idle\u0026#39;, resetCallback) ]); 状态查询和预测 // 检查当前状态是否可以接收特定事件 if (sm.can(\u0026#39;PAUSE\u0026#39;)) { // 可以执行暂停操作 } // 获取事件触发后的下一个状态 const nextState = sm.getNextState(\u0026#39;STOP\u0026#39;); // \u0026#39;stopped\u0026#39; // 检查当前是否为终止状态（没有可用的出站转换） if (sm.isFinal()) { // 到达终止状态 } 子状态机 子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\n// 创建子状态机 const subMachine = new StateMachine\u0026lt;SubState, SubEvent\u0026gt;(\u0026#39;subIdle\u0026#39;, [ t(\u0026#39;subIdle\u0026#39;, \u0026#39;SUB_START\u0026#39;, \u0026#39;subRunning\u0026#39;), t(\u0026#39;subRunning\u0026#39;, \u0026#39;SUB_STOP\u0026#39;, \u0026#39;subStopped\u0026#39;) ]); // 创建主状态机 const mainMachine = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;) ]); // 将子状态机附加到主状态机的特定状态 mainMachine.addSubStateMachine(\u0026#39;running\u0026#39;, subMachine); 核心设计问题 状态切换回掉的处理 每次派发事件，状态机会立即进行响应，更新新的状态 针对事件切换回调函数执行，不会卡住状态机的状态 极端情况下，存在多个状态回调函数同时在执行的情况 子状态机的生命周期 当主状态机进入子状态时，子状态机被激活 子状态机可以处理自己的事件和状态转换。 当主状态机离开子状态时，子状态机被自动重置（reset） 子状态机只有在父状态机处于激活状态时才能接收事件 实际应用示例 游戏角色控制 graph TD Standing[Standing] --\u0026gt; |WALK| Walking[Walking] Walking --\u0026gt; |STOP| Standing Standing --\u0026gt; |JUMP| Jumping[Jumping] Walking --\u0026gt; |JUMP| Jumping Jumping --\u0026gt; |LAND| Standing Standing --\u0026gt; |ATTACK| Attacking[Attacking] Walking --\u0026gt; |ATTACK| Attacking Jumping --\u0026gt; |ATTACK| Attacking Attacking --\u0026gt; |STOP| Standing type CharacterState = \u0026#39;standing\u0026#39; | \u0026#39;walking\u0026#39; | \u0026#39;jumping\u0026#39; | \u0026#39;attacking\u0026#39;; type CharacterEvent = \u0026#39;WALK\u0026#39; | \u0026#39;JUMP\u0026#39; | \u0026#39;ATTACK\u0026#39; | \u0026#39;STOP\u0026#39; | \u0026#39;LAND\u0026#39;; // 创建角色状态机 const character = new StateMachine\u0026lt;CharacterState, CharacterEvent\u0026gt;(\u0026#39;standing\u0026#39;, [ t(\u0026#39;standing\u0026#39;, \u0026#39;WALK\u0026#39;, \u0026#39;walking\u0026#39;, startWalkAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopWalkAnimation), t(\u0026#39;standing\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;jumping\u0026#39;, \u0026#39;LAND\u0026#39;, \u0026#39;standing\u0026#39;, landAnimation), t(ANY_STATE, \u0026#39;ATTACK\u0026#39;, \u0026#39;attacking\u0026#39;, attackAnimation), t(\u0026#39;attacking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopAttackAnimation), ]); UI 组件状态管理 graph TD Normal[Normal] --\u0026gt; |MOUSE_ENTER| Hover[Hover] Hover --\u0026gt; |MOUSE_LEAVE| Normal Hover --\u0026gt; |MOUSE_DOWN| Pressed[Pressed] Pressed --\u0026gt; |MOUSE_UP| Hover Pressed --\u0026gt; |MOUSE_LEAVE| Normal Normal --\u0026gt; |DISABLE| Disabled[Disabled] Hover --\u0026gt; |DISABLE| Disabled Pressed --\u0026gt; |DISABLE| Disabled Disabled --\u0026gt; |ENABLE| Normal type ButtonState = \u0026#39;normal\u0026#39; | \u0026#39;hover\u0026#39; | \u0026#39;pressed\u0026#39; | \u0026#39;disabled\u0026#39;; type ButtonEvent = \u0026#39;MOUSE_ENTER\u0026#39; | \u0026#39;MOUSE_LEAVE\u0026#39; | \u0026#39;MOUSE_DOWN\u0026#39; | \u0026#39;MOUSE_UP\u0026#39; | \u0026#39;DISABLE\u0026#39; | \u0026#39;ENABLE\u0026#39;; // 创建按钮状态机 const button = new StateMachine\u0026lt;ButtonState, ButtonEvent\u0026gt;(\u0026#39;normal\u0026#39;, [ t(\u0026#39;normal\u0026#39;, \u0026#39;MOUSE_ENTER\u0026#39;, \u0026#39;hover\u0026#39;, showHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_DOWN\u0026#39;, \u0026#39;pressed\u0026#39;, showPressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_UP\u0026#39;, \u0026#39;hover\u0026#39;, removePressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeAllEffects), t(ANY_STATE, \u0026#39;DISABLE\u0026#39;, \u0026#39;disabled\u0026#39;, disableButton), t(\u0026#39;disabled\u0026#39;, \u0026#39;ENABLE\u0026#39;, \u0026#39;normal\u0026#39;, enableButton), ]); 游戏角色管理系统 这个例子展示了如何使用嵌套状态机来管理游戏角色的复杂状态。主状态机处理角色的生命周期（闲置、活动、死亡），而子状态机则专注于角色在\u0026quot;活动\u0026quot;状态下可以执行的各种行为\nstateDiagram-v2 [*] --\u0026gt; idle idle --\u0026gt; active: ACTIVATE active --\u0026gt; idle: REST active --\u0026gt; dead: DIE dead --\u0026gt; idle: RESPAWN state active { [*] --\u0026gt; moving moving --\u0026gt; fighting: ENGAGE fighting --\u0026gt; moving: DISENGAGE moving --\u0026gt; interacting: INTERACT interacting --\u0026gt; moving: FINISH } // 主状态机状态和事件 type MainState = \u0026#39;idle\u0026#39; | \u0026#39;active\u0026#39; | \u0026#39;dead\u0026#39;; type MainEvent = \u0026#39;ACTIVATE\u0026#39; | \u0026#39;REST\u0026#39; | \u0026#39;DIE\u0026#39; | \u0026#39;RESPAWN\u0026#39;; // 子状态机状态和事件 type ActiveState = \u0026#39;moving\u0026#39; | \u0026#39;fighting\u0026#39; | \u0026#39;interacting\u0026#39;; type ActiveEvent = \u0026#39;ENGAGE\u0026#39; | \u0026#39;DISENGAGE\u0026#39; | \u0026#39;INTERACT\u0026#39; | \u0026#39;FINISH\u0026#39;; // 创建子状态机（角色活动状态） const activeStateMachine = new StateMachine\u0026lt;ActiveState, ActiveEvent\u0026gt;(\u0026#39;moving\u0026#39;, [ t(\u0026#39;moving\u0026#39;, \u0026#39;ENGAGE\u0026#39;, \u0026#39;fighting\u0026#39;, startCombatSystem), t(\u0026#39;fighting\u0026#39;, \u0026#39;DISENGAGE\u0026#39;, \u0026#39;moving\u0026#39;, endCombatSystem), t(\u0026#39;moving\u0026#39;, \u0026#39;INTERACT\u0026#39;, \u0026#39;interacting\u0026#39;, startInteraction), t(\u0026#39;interacting\u0026#39;, \u0026#39;FINISH\u0026#39;, \u0026#39;moving\u0026#39;, endInteraction) ]); // 创建主状态机（角色生命周期） const characterManager = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;ACTIVATE\u0026#39;, \u0026#39;active\u0026#39;, activateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;REST\u0026#39;, \u0026#39;idle\u0026#39;, deactivateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;DIE\u0026#39;, \u0026#39;dead\u0026#39;, handleDeath), t(\u0026#39;dead\u0026#39;, \u0026#39;RESPAWN\u0026#39;, \u0026#39;idle\u0026#39;, handleRespawn) ]); // 将活动状态子状态机附加到主状态机的\u0026#34;active\u0026#34;状态 characterManager.addSubStateMachine(\u0026#39;active\u0026#39;, activeStateMachine); // 使用示例 await characterManager.dispatch(\u0026#39;ACTIVATE\u0026#39;); // 进入active状态，子状态机激活 await activeStateMachine.dispatch(\u0026#39;ENGAGE\u0026#39;); // 切换到战斗状态 await activeStateMachine.dispatch(\u0026#39;DISENGAGE\u0026#39;); // 返回移动状态 await characterManager.dispatch(\u0026#39;REST\u0026#39;); // 回到idle状态，子状态机重置 结合 和UI结合 您的浏览器不支持视频标签。 和AI结合 您的浏览器不支持视频标签。 总结 状态机提供了一种清晰、直观的方式来管理复杂系统的状态转换逻辑。通过明确定义状态、事件和转换规则，可以有效避免状态管理中的混乱和错误。子状态机机制进一步增强了状态机的能力，使其能够处理更复杂的分层状态结构。无论是游戏开发、UI交互还是业务流程管理，状态机都是一种强大而灵活的解决方案。\n","permalink":"https://genluo.github.io/my-blog/posts/statemachine/","summary":"\u003ch2 id=\"状态机概述\"\u003e状态机概述\u003c/h2\u003e\n\u003cp\u003e状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\u003c/p\u003e\n\u003ch2 id=\"核心概念\"\u003e核心概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e状态（State）\u003c/strong\u003e：系统可能处于的一种情况或模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e事件（Event）\u003c/strong\u003e：触发状态转换的信号或动作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e转换（Transition）\u003c/strong\u003e：定义从一个状态到另一个状态的规则。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回调（Callback）\u003c/strong\u003e：状态转换时执行的逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"应用场景\"\u003e应用场景\u003c/h2\u003e\n\u003cp\u003e状态机在以下场景中特别有用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。\u003c/li\u003e\n\u003cli\u003eUI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。\u003c/li\u003e\n\u003cli\u003e工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。\u003c/li\u003e\n\u003cli\u003e协议实现：网络协议的状态管理（连接中、已连接、断开连接）。\u003c/li\u003e\n\u003cli\u003e动画控制：管理动画序列和转换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本用法\"\u003e基本用法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义状态和事件类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 创建状态机实例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStateMachine\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003eState\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e\u0026gt;(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 触发状态转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003edispatch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// idle -\u0026gt; running\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetState\u003c/span\u003e());  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;running\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"高级特性\"\u003e高级特性\u003c/h2\u003e\n\u003ch3 id=\"全局事件any_state\"\u003e全局事件（ANY_STATE）\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eANY_STATE\u003c/code\u003e 符号定义可从任意状态触发的转换：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// RESET 事件可从任何状态回到 idle 状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddTransitions\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eANY_STATE\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eresetCallback\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"状态查询和预测\"\u003e状态查询和预测\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前状态是否可以接收特定事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecan\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 可以执行暂停操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 获取事件触发后的下一个状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enextState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetNextState\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;stopped\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前是否为终止状态（没有可用的出站转换）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eisFinal\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 到达终止状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"子状态机\"\u003e子状态机\u003c/h3\u003e\n\u003cp\u003e子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\u003c/p\u003e","title":"StateMachine"},{"content":"关于我 做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出性能强劲，用户体验优异，能产生业务价值的产品\n常用工具箱 语言：TypeScript、C++ 框架：React、NestJs 运行时：Node.js、Chrome/浏览器、visionOS 标准：webGPU、WebAssembly、 历史项目 淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频） 淘宝3D引擎对应的相关产品 端渲染和云渲染协同切换（webRTC、追帧算法） 引擎Binding技术方案落地（quickJS、wasm） 引擎对应的3D编辑器（编辑器、节点编辑、AI Agent） 专利 一种基于端云协同的三维场景加载及渲染技术（2024-01-12） 全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17） 联系方式 邮箱：isgenluo@gmail.com GitHub：我的GitHub主页 ","permalink":"https://genluo.github.io/my-blog/about/","summary":"\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cp\u003e做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出\u003cstrong\u003e性能强劲\u003c/strong\u003e，用户\u003cstrong\u003e体验优异\u003c/strong\u003e，能产生业务价值的产品\u003c/p\u003e\n\u003ch3 id=\"常用工具箱\"\u003e常用工具箱\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e语言：TypeScript、C++\u003c/li\u003e\n\u003cli\u003e框架：React、NestJs\u003c/li\u003e\n\u003cli\u003e运行时：Node.js、Chrome/浏览器、visionOS\u003c/li\u003e\n\u003cli\u003e标准：webGPU、WebAssembly、\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"历史项目\"\u003e历史项目\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频）\u003c/li\u003e\n\u003cli\u003e淘宝3D引擎对应的相关产品\n\u003cul\u003e\n\u003cli\u003e端渲染和云渲染协同切换（webRTC、追帧算法）\u003c/li\u003e\n\u003cli\u003e引擎Binding技术方案落地（quickJS、wasm）\u003c/li\u003e\n\u003cli\u003e引擎对应的3D编辑器（编辑器、节点编辑、AI Agent）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"专利\"\u003e专利\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一种基于端云协同的三维场景加载及渲染技术（2024-01-12）\u003c/li\u003e\n\u003cli\u003e全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"联系方式\"\u003e联系方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e邮箱：\u003ca href=\"mailto:isgenluo@gmail.com\"\u003eisgenluo@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGitHub：\u003ca href=\"https://github.com/genluo\"\u003e我的GitHub主页\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"关于我"}]