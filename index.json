[{"content":"最近试用了下 augment 进行一些需求开发，感觉相比 cursor 还是解决了一些问题，挺好的进行分享下\n上下文机制 如何进行跨仓库开发，以前使用 cursor 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。 通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\n工具 另外一个比较好的点是 augment 提供了一些工具配置，可以一键进行安装使用\n任务规划 提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用 同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\n图表展示 不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好 提示词优化 可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用 ","permalink":"https://genluo.github.io/my-blog/posts/augment/","summary":"\u003cp\u003e最近试用了下 \u003ccode\u003eaugment\u003c/code\u003e 进行一些需求开发，感觉相比 \u003ccode\u003ecursor\u003c/code\u003e 还是解决了一些问题，挺好的进行分享下\u003c/p\u003e\n\u003ch2 id=\"上下文机制\"\u003e上下文机制\u003c/h2\u003e\n\u003cp\u003e如何进行跨仓库开发，以前使用 \u003ccode\u003ecursor\u003c/code\u003e 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\u003c/p\u003e\n\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\n\u003cp\u003e另外一个比较好的点是 \u003ccode\u003eaugment\u003c/code\u003e 提供了一些工具配置，可以一键进行安装使用\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image1.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"任务规划\"\u003e任务规划\u003c/h2\u003e\n\u003cp\u003e提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\u003c/p\u003e\n\u003ch2 id=\"图表展示\"\u003e图表展示\u003c/h2\u003e\n\u003cp\u003e不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image3.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"提示词优化\"\u003e提示词优化\u003c/h2\u003e\n\u003cp\u003e可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-2.png\"\u003e\u003c/p\u003e","title":"Augment 试用"},{"content":"状态机概述 状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\n核心概念 状态（State）：系统可能处于的一种情况或模式。 事件（Event）：触发状态转换的信号或动作。 转换（Transition）：定义从一个状态到另一个状态的规则。 回调（Callback）：状态转换时执行的逻辑。 应用场景 状态机在以下场景中特别有用：\n游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。 UI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。 工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。 协议实现：网络协议的状态管理（连接中、已连接、断开连接）。 动画控制：管理动画序列和转换。 基本用法 // 定义状态和事件类型 type State = \u0026#39;idle\u0026#39; | \u0026#39;running\u0026#39; | \u0026#39;paused\u0026#39; | \u0026#39;stopped\u0026#39;; type Event = \u0026#39;START\u0026#39; | \u0026#39;PAUSE\u0026#39; | \u0026#39;RESUME\u0026#39; | \u0026#39;STOP\u0026#39;; // 创建状态机实例 const sm = new StateMachine\u0026lt;State, Event\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;PAUSE\u0026#39;, \u0026#39;paused\u0026#39;), t(\u0026#39;paused\u0026#39;, \u0026#39;RESUME\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;), ]); // 触发状态转换 await sm.dispatch(\u0026#39;START\u0026#39;); // idle -\u0026gt; running console.log(sm.getState()); // \u0026#39;running\u0026#39; 高级特性 全局事件（ANY_STATE） 使用 ANY_STATE 符号定义可从任意状态触发的转换：\n// RESET 事件可从任何状态回到 idle 状态 sm.addTransitions([ t(ANY_STATE, \u0026#39;RESET\u0026#39;, \u0026#39;idle\u0026#39;, resetCallback) ]); 状态查询和预测 // 检查当前状态是否可以接收特定事件 if (sm.can(\u0026#39;PAUSE\u0026#39;)) { // 可以执行暂停操作 } // 获取事件触发后的下一个状态 const nextState = sm.getNextState(\u0026#39;STOP\u0026#39;); // \u0026#39;stopped\u0026#39; // 检查当前是否为终止状态（没有可用的出站转换） if (sm.isFinal()) { // 到达终止状态 } 子状态机 子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\n// 创建子状态机 const subMachine = new StateMachine\u0026lt;SubState, SubEvent\u0026gt;(\u0026#39;subIdle\u0026#39;, [ t(\u0026#39;subIdle\u0026#39;, \u0026#39;SUB_START\u0026#39;, \u0026#39;subRunning\u0026#39;), t(\u0026#39;subRunning\u0026#39;, \u0026#39;SUB_STOP\u0026#39;, \u0026#39;subStopped\u0026#39;) ]); // 创建主状态机 const mainMachine = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;) ]); // 将子状态机附加到主状态机的特定状态 mainMachine.addSubStateMachine(\u0026#39;running\u0026#39;, subMachine); 核心设计问题 状态切换回掉的处理 每次派发事件，状态机会立即进行响应，更新新的状态 针对事件切换回调函数执行，不会卡住状态机的状态 极端情况下，存在多个状态回调函数同时在执行的情况 子状态机的生命周期 当主状态机进入子状态时，子状态机被激活 子状态机可以处理自己的事件和状态转换。 当主状态机离开子状态时，子状态机被自动重置（reset） 子状态机只有在父状态机处于激活状态时才能接收事件 实际应用示例 游戏角色控制 graph TD Standing[Standing] --\u0026gt; |WALK| Walking[Walking] Walking --\u0026gt; |STOP| Standing Standing --\u0026gt; |JUMP| Jumping[Jumping] Walking --\u0026gt; |JUMP| Jumping Jumping --\u0026gt; |LAND| Standing Standing --\u0026gt; |ATTACK| Attacking[Attacking] Walking --\u0026gt; |ATTACK| Attacking Jumping --\u0026gt; |ATTACK| Attacking Attacking --\u0026gt; |STOP| Standing type CharacterState = \u0026#39;standing\u0026#39; | \u0026#39;walking\u0026#39; | \u0026#39;jumping\u0026#39; | \u0026#39;attacking\u0026#39;; type CharacterEvent = \u0026#39;WALK\u0026#39; | \u0026#39;JUMP\u0026#39; | \u0026#39;ATTACK\u0026#39; | \u0026#39;STOP\u0026#39; | \u0026#39;LAND\u0026#39;; // 创建角色状态机 const character = new StateMachine\u0026lt;CharacterState, CharacterEvent\u0026gt;(\u0026#39;standing\u0026#39;, [ t(\u0026#39;standing\u0026#39;, \u0026#39;WALK\u0026#39;, \u0026#39;walking\u0026#39;, startWalkAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopWalkAnimation), t(\u0026#39;standing\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;jumping\u0026#39;, \u0026#39;LAND\u0026#39;, \u0026#39;standing\u0026#39;, landAnimation), t(ANY_STATE, \u0026#39;ATTACK\u0026#39;, \u0026#39;attacking\u0026#39;, attackAnimation), t(\u0026#39;attacking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopAttackAnimation), ]); UI 组件状态管理 graph TD Normal[Normal] --\u0026gt; |MOUSE_ENTER| Hover[Hover] Hover --\u0026gt; |MOUSE_LEAVE| Normal Hover --\u0026gt; |MOUSE_DOWN| Pressed[Pressed] Pressed --\u0026gt; |MOUSE_UP| Hover Pressed --\u0026gt; |MOUSE_LEAVE| Normal Normal --\u0026gt; |DISABLE| Disabled[Disabled] Hover --\u0026gt; |DISABLE| Disabled Pressed --\u0026gt; |DISABLE| Disabled Disabled --\u0026gt; |ENABLE| Normal type ButtonState = \u0026#39;normal\u0026#39; | \u0026#39;hover\u0026#39; | \u0026#39;pressed\u0026#39; | \u0026#39;disabled\u0026#39;; type ButtonEvent = \u0026#39;MOUSE_ENTER\u0026#39; | \u0026#39;MOUSE_LEAVE\u0026#39; | \u0026#39;MOUSE_DOWN\u0026#39; | \u0026#39;MOUSE_UP\u0026#39; | \u0026#39;DISABLE\u0026#39; | \u0026#39;ENABLE\u0026#39;; // 创建按钮状态机 const button = new StateMachine\u0026lt;ButtonState, ButtonEvent\u0026gt;(\u0026#39;normal\u0026#39;, [ t(\u0026#39;normal\u0026#39;, \u0026#39;MOUSE_ENTER\u0026#39;, \u0026#39;hover\u0026#39;, showHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_DOWN\u0026#39;, \u0026#39;pressed\u0026#39;, showPressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_UP\u0026#39;, \u0026#39;hover\u0026#39;, removePressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeAllEffects), t(ANY_STATE, \u0026#39;DISABLE\u0026#39;, \u0026#39;disabled\u0026#39;, disableButton), t(\u0026#39;disabled\u0026#39;, \u0026#39;ENABLE\u0026#39;, \u0026#39;normal\u0026#39;, enableButton), ]); 游戏角色管理系统 这个例子展示了如何使用嵌套状态机来管理游戏角色的复杂状态。主状态机处理角色的生命周期（闲置、活动、死亡），而子状态机则专注于角色在\u0026quot;活动\u0026quot;状态下可以执行的各种行为\nstateDiagram-v2 [*] --\u0026gt; idle idle --\u0026gt; active: ACTIVATE active --\u0026gt; idle: REST active --\u0026gt; dead: DIE dead --\u0026gt; idle: RESPAWN state active { [*] --\u0026gt; moving moving --\u0026gt; fighting: ENGAGE fighting --\u0026gt; moving: DISENGAGE moving --\u0026gt; interacting: INTERACT interacting --\u0026gt; moving: FINISH } // 主状态机状态和事件 type MainState = \u0026#39;idle\u0026#39; | \u0026#39;active\u0026#39; | \u0026#39;dead\u0026#39;; type MainEvent = \u0026#39;ACTIVATE\u0026#39; | \u0026#39;REST\u0026#39; | \u0026#39;DIE\u0026#39; | \u0026#39;RESPAWN\u0026#39;; // 子状态机状态和事件 type ActiveState = \u0026#39;moving\u0026#39; | \u0026#39;fighting\u0026#39; | \u0026#39;interacting\u0026#39;; type ActiveEvent = \u0026#39;ENGAGE\u0026#39; | \u0026#39;DISENGAGE\u0026#39; | \u0026#39;INTERACT\u0026#39; | \u0026#39;FINISH\u0026#39;; // 创建子状态机（角色活动状态） const activeStateMachine = new StateMachine\u0026lt;ActiveState, ActiveEvent\u0026gt;(\u0026#39;moving\u0026#39;, [ t(\u0026#39;moving\u0026#39;, \u0026#39;ENGAGE\u0026#39;, \u0026#39;fighting\u0026#39;, startCombatSystem), t(\u0026#39;fighting\u0026#39;, \u0026#39;DISENGAGE\u0026#39;, \u0026#39;moving\u0026#39;, endCombatSystem), t(\u0026#39;moving\u0026#39;, \u0026#39;INTERACT\u0026#39;, \u0026#39;interacting\u0026#39;, startInteraction), t(\u0026#39;interacting\u0026#39;, \u0026#39;FINISH\u0026#39;, \u0026#39;moving\u0026#39;, endInteraction) ]); // 创建主状态机（角色生命周期） const characterManager = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;ACTIVATE\u0026#39;, \u0026#39;active\u0026#39;, activateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;REST\u0026#39;, \u0026#39;idle\u0026#39;, deactivateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;DIE\u0026#39;, \u0026#39;dead\u0026#39;, handleDeath), t(\u0026#39;dead\u0026#39;, \u0026#39;RESPAWN\u0026#39;, \u0026#39;idle\u0026#39;, handleRespawn) ]); // 将活动状态子状态机附加到主状态机的\u0026#34;active\u0026#34;状态 characterManager.addSubStateMachine(\u0026#39;active\u0026#39;, activeStateMachine); // 使用示例 await characterManager.dispatch(\u0026#39;ACTIVATE\u0026#39;); // 进入active状态，子状态机激活 await activeStateMachine.dispatch(\u0026#39;ENGAGE\u0026#39;); // 切换到战斗状态 await activeStateMachine.dispatch(\u0026#39;DISENGAGE\u0026#39;); // 返回移动状态 await characterManager.dispatch(\u0026#39;REST\u0026#39;); // 回到idle状态，子状态机重置 结合 和UI结合 您的浏览器不支持视频标签。 和AI结合 您的浏览器不支持视频标签。 总结 状态机提供了一种清晰、直观的方式来管理复杂系统的状态转换逻辑。通过明确定义状态、事件和转换规则，可以有效避免状态管理中的混乱和错误。子状态机机制进一步增强了状态机的能力，使其能够处理更复杂的分层状态结构。无论是游戏开发、UI交互还是业务流程管理，状态机都是一种强大而灵活的解决方案。\n","permalink":"https://genluo.github.io/my-blog/posts/statemachine/","summary":"\u003ch2 id=\"状态机概述\"\u003e状态机概述\u003c/h2\u003e\n\u003cp\u003e状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\u003c/p\u003e\n\u003ch2 id=\"核心概念\"\u003e核心概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e状态（State）\u003c/strong\u003e：系统可能处于的一种情况或模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e事件（Event）\u003c/strong\u003e：触发状态转换的信号或动作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e转换（Transition）\u003c/strong\u003e：定义从一个状态到另一个状态的规则。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回调（Callback）\u003c/strong\u003e：状态转换时执行的逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"应用场景\"\u003e应用场景\u003c/h2\u003e\n\u003cp\u003e状态机在以下场景中特别有用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。\u003c/li\u003e\n\u003cli\u003eUI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。\u003c/li\u003e\n\u003cli\u003e工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。\u003c/li\u003e\n\u003cli\u003e协议实现：网络协议的状态管理（连接中、已连接、断开连接）。\u003c/li\u003e\n\u003cli\u003e动画控制：管理动画序列和转换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本用法\"\u003e基本用法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义状态和事件类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 创建状态机实例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStateMachine\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003eState\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e\u0026gt;(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 触发状态转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003edispatch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// idle -\u0026gt; running\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetState\u003c/span\u003e());  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;running\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"高级特性\"\u003e高级特性\u003c/h2\u003e\n\u003ch3 id=\"全局事件any_state\"\u003e全局事件（ANY_STATE）\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eANY_STATE\u003c/code\u003e 符号定义可从任意状态触发的转换：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// RESET 事件可从任何状态回到 idle 状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddTransitions\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eANY_STATE\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eresetCallback\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"状态查询和预测\"\u003e状态查询和预测\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前状态是否可以接收特定事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecan\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 可以执行暂停操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 获取事件触发后的下一个状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enextState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetNextState\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;stopped\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前是否为终止状态（没有可用的出站转换）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eisFinal\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 到达终止状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"子状态机\"\u003e子状态机\u003c/h3\u003e\n\u003cp\u003e子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\u003c/p\u003e","title":"StateMachine"},{"content":"关于本站 这是我的个人博客网站，使用Hugo构建。在这里，我会分享我的想法、经验和学习心得。\n关于我 我是一名技术爱好者，对编程和新技术充满热情。欢迎与我交流！\n联系方式 邮箱：example@email.com GitHub：我的GitHub主页 ","permalink":"https://genluo.github.io/my-blog/about/","summary":"\u003ch2 id=\"关于本站\"\u003e关于本站\u003c/h2\u003e\n\u003cp\u003e这是我的个人博客网站，使用Hugo构建。在这里，我会分享我的想法、经验和学习心得。\u003c/p\u003e\n\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cp\u003e我是一名技术爱好者，对编程和新技术充满热情。欢迎与我交流！\u003c/p\u003e\n\u003ch2 id=\"联系方式\"\u003e联系方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e邮箱：\u003ca href=\"mailto:example@email.com\"\u003eexample@email.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGitHub：\u003ca href=\"https://github.com/genluo\"\u003e我的GitHub主页\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"关于我"}]