[{"content":"基本配置 一般来说，vscode 中开发 c++ 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 clangd ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\n基础配置 如果使用 cmake 进行开发，可以添加编译参数 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 来生成 clangd 需要的 compile_commands.json 来索引整个项目的源文件\n通过 cmake 进行配置生成，包含 bear 工具介绍 generates a compilation database for clang tooling.\n如果使用的是其他的构建系统，没有使用 cmake 可以使用这个工具，生成对应的 compile_commands.json\nbear -- make 重启服务之后，可以正常进行跳转\n","permalink":"https://genluo.github.io/my-blog/posts/vscode+clangd/","summary":"\u003ch2 id=\"基本配置\"\u003e基本配置\u003c/h2\u003e\n\u003cp\u003e一般来说，\u003ccode\u003evscode\u003c/code\u003e 中开发 \u003ccode\u003ec++\u003c/code\u003e 项目使用的都是微软提供的插件，但是这个插件不是很好用，推荐使用 \u003ccode\u003eclangd\u003c/code\u003e ，相比于微软的插件来说，错误的提示更好点，同时速度要快很多\u003c/p\u003e\n\u003ch3 id=\"基础配置\"\u003e基础配置\u003c/h3\u003e\n\u003cp\u003e如果使用 \u003ccode\u003ecmake\u003c/code\u003e 进行开发，可以添加编译参数 \u003ccode\u003e-DCMAKE_EXPORT_COMPILE_COMMANDS=ON\u003c/code\u003e 来生成 \u003ccode\u003eclangd\u003c/code\u003e 需要的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e 来索引整个项目的源文件\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ecmake\u003c/code\u003e 进行配置生成，包含\n\u003cimg loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-3.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"bear-工具介绍\"\u003e\u003ca href=\"https://github.com/rizsotto/Bear\"\u003ebear\u003c/a\u003e 工具介绍\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003egenerates a compilation database for clang tooling.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e如果使用的是其他的构建系统，没有使用 \u003ccode\u003ecmake\u003c/code\u003e 可以使用这个工具，生成对应的 \u003ccode\u003ecompile_commands.json\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebear -- make\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e重启服务之后，可以正常进行跳转\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-5.png\"\u003e\u003c/p\u003e","title":"Vscode+clangd"},{"content":"整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\n要点 内容需要详细，不要概括笼统，月具体越好 让模型充当一个角色，让其更加专业和明确 使用分割符来区分输出的不同部分 指定任务完成的步骤，将复杂任务简化 提供示例，给模型进行参考 指定输出长度 内容 1. 确定角色定义 明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\n要点：\n具体的职业身份（如：高级软件架构师、产品经理、数据分析师） 相关的专业背景和经验 工作场景和责任范围 与用户的关系定位 示例：\n## 角色定义 你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。 2. 确定核心目标 清晰描述希望 AI 完成的主要任务和期望达到的效果。\n要点：\n主要任务的具体描述 预期的输出结果 成功的衡量标准 目标用户和使用场景 示例：\n## 核心目标 - **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档 3. 确定关键规则 设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\n要点：\n约束AI 的行为 内容的准确性标准 禁止的行为或内容 特殊情况的处理方式 示例：\n## 关键规则 - **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节 - **防简化要求**：严格遵循 `./anti-simplification-rules.md` 中的防简化规则，绝对禁止简化、概述、总结原始需求内容 4. 确定执行流程 定义 AI 处理任务的具体步骤和逻辑顺序。\n要点：\n分析问题的步骤 信息收集和处理流程 决策和推理过程 输出生成的顺序 示例：\n## 拆解执行流程 ### 任务1：知识了解 **目标**：深入学习XXX互动游戏框架的核心知识和互动基座架构 **执行清单**： 1. **阅读xxxx文档**： - 仔细阅读 `.xxx.md` 文件 - 重点理解xxxx的定义和概念、功能 2. **阅读xxxx模型文档**： - 仔细阅读 `.xxxx.md` 文件 - 重点理解xxx模型的核心概念、数据结构和业务流程 - 识别关键实体和它们之间的关系 3. **阅读互动基座架构文档**： - 仔细阅读 `.xxxx.md` 文件 - 理解互动基座的整体架构设计、各层职责和模块划分 - 掌握技术实现细节和集成方式 4. **知识整合分析**： - 分析两个文档中的关键信息点 - 建立xxxx模型与互动基座架构之间的映射关系 - 识别业务概念到技术实现的转换路径 ### 任务2：环境准备 **目标**：建立标准化的文档目录结构 **执行清单**： 1. ✅ 检查并创建根目录：`./docs` 2. ✅ 检查并创建需求目录：`./docs/requirements` 3. ✅ 检查并创建子需求目录：`./docs/sub_requirements` 4. ✅ 检查并创建功能设计目录：`./docs/function_designs` 5. ✅ 验证原始需求文件存在：`./docs/requirements/{需求ID}.md` ### 任务3：需求分析与拆解 **目标**：基于xxxx模型进行系统性需求分析 **输出**：需求拆解分析报告 ### 任务4：子需求文档生成 **目标**：创建结构化的子需求文档 **文档规范**： **输出**：完整的子需求文档集合 ### 任务5：一致性保证 **目标**：确保所有文档间的技术一致性 **输出**：技术一致性报告 5. 确定输出模版 规范化输出格式，确保信息的结构化和易读性。\n要点：\n固定的输出结构 各部分的内容要求 格式化规范 示例和模板 示例：\n## 需求文档模版 整体务必遵循 .xxx-split-template.md 模版的格式 输出模版 # [产品包名称]技术方案 \u0026gt; **使用说明：** 本模板适用于XXX互动游戏框架的产品包技术方案设计，请根据实际情况填写各个章节内容。带有 `[占位符]` 的内容需要替换为具体信息。 ## 概述 \u0026gt; **填写指导：** 用1-2句话简洁描述产品包的核心定位和技术实现方式，说明其基于IGF框架的扩展方案。 [产品包名称]是[目标活动/业务场景]的[核心功能定位]，负责[主要功能1]、[主要功能2]、[主要功能3]等功能。本技术方案基于 xxxx 基座的 [骨架名称] 骨架进行扩展实现，采用 IGF [框架类型]框架实现[核心玩法/业务逻辑]。 .... 大模型参数 Temperature：简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。 Top_p：同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。 Max Length：您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。 Stop Sequences：stop sequence 是一个字符串，可以阻止模型生成 token，指定 stop sequences 是控制大模型响应长度和结构的另一种方法。例如，您可以通过添加 “11” 作为 stop sequence 来告诉模型生成不超过 10 个项的列表。 Frequency Penalty：frequency penalty 是对下一个生成的 token 进行惩罚，这个惩罚和 token 在响应和提示中已出现的次数成比例， frequency penalty 越高，某个词再次出现的可能性就越小，这个设置通过给 重复数量多的 Token 设置更高的惩罚来减少响应中单词的重复。 Presence Penalty：presence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。 参考 https://www.promptingguide.ai/zh ","permalink":"https://genluo.github.io/my-blog/posts/prompt/","summary":"\u003cp\u003e整个 AI Agent 的开发流程中，编写高质量的 Prompt 非常重要，目前总结了一些 writing prompt 的技巧，可以作为后续的参考\u003c/p\u003e\n\u003ch2 id=\"要点\"\u003e要点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e内容需要详细，不要概括笼统，月具体越好\u003c/li\u003e\n\u003cli\u003e让模型充当一个角色，让其更加专业和明确\u003c/li\u003e\n\u003cli\u003e使用分割符来区分输出的不同部分\u003c/li\u003e\n\u003cli\u003e指定任务完成的步骤，将复杂任务简化\u003c/li\u003e\n\u003cli\u003e提供示例，给模型进行参考\u003c/li\u003e\n\u003cli\u003e指定输出长度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"内容\"\u003e内容\u003c/h2\u003e\n\u003ch3 id=\"1-确定角色定义\"\u003e1. 确定角色定义\u003c/h3\u003e\n\u003cp\u003e明确定义 AI 的身份和专业背景，这决定了 AI 的回答风格和专业程度。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e具体的职业身份（如：高级软件架构师、产品经理、数据分析师）\u003c/li\u003e\n\u003cli\u003e相关的专业背景和经验\u003c/li\u003e\n\u003cli\u003e工作场景和责任范围\u003c/li\u003e\n\u003cli\u003e与用户的关系定位\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 角色定义\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e你是一个专门负责XXX互动游戏框架的高级需求分析师，具备深度的技术架构理解能力和丰富的互动营销产品经验。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-确定核心目标\"\u003e2. 确定核心目标\u003c/h3\u003e\n\u003cp\u003e清晰描述希望 AI 完成的主要任务和期望达到的效果。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主要任务的具体描述\u003c/li\u003e\n\u003cli\u003e预期的输出结果\u003c/li\u003e\n\u003cli\u003e成功的衡量标准\u003c/li\u003e\n\u003cli\u003e目标用户和使用场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 核心目标\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **产出需求文档**：你的主要职责是将复杂的互动营销产品需求与现有的XXX基座能力进行深度结合，系统性地拆分成技术边界清晰、可独立开发和测试的产品包需求模块，并生成标准化的产品包需求文档\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"3-确定关键规则\"\u003e3. 确定关键规则\u003c/h3\u003e\n\u003cp\u003e设定 AI 行为的边界和约束条件，确保输出的质量和一致性，迭代过程中可以持续拓展相关规则\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e约束AI 的行为\u003c/li\u003e\n\u003cli\u003e内容的准确性标准\u003c/li\u003e\n\u003cli\u003e禁止的行为或内容\u003c/li\u003e\n\u003cli\u003e特殊情况的处理方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e## 关键规则\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **后端聚焦**：一定只提取后端功能需求（业务逻辑、数据处理、系统集成），必须忽略前端实现细节\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e-\u003c/span\u003e **防简化要求**：严格遵循 \u003cspan style=\"color:#e6db74\"\u003e`./anti-simplification-rules.md`\u003c/span\u003e 中的防简化规则，绝对禁止简化、概述、总结原始需求内容\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"4-确定执行流程\"\u003e4. 确定执行流程\u003c/h3\u003e\n\u003cp\u003e定义 AI 处理任务的具体步骤和逻辑顺序。\u003c/p\u003e","title":"如何写出高质量的 Prompt"},{"content":"最近试用了下 augment 进行一些需求开发，感觉相比 cursor 还是解决了一些问题，挺好的进行分享下\n上下文机制 如何进行跨仓库开发，以前使用 cursor 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。 通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\n工具 另外一个比较好的点是 augment 提供了一些工具配置，可以一键进行安装使用\n任务规划 提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用 同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\n图表展示 不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好 提示词优化 可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用 ","permalink":"https://genluo.github.io/my-blog/posts/augment/","summary":"\u003cp\u003e最近试用了下 \u003ccode\u003eaugment\u003c/code\u003e 进行一些需求开发，感觉相比 \u003ccode\u003ecursor\u003c/code\u003e 还是解决了一些问题，挺好的进行分享下\u003c/p\u003e\n\u003ch2 id=\"上下文机制\"\u003e上下文机制\u003c/h2\u003e\n\u003cp\u003e如何进行跨仓库开发，以前使用 \u003ccode\u003ecursor\u003c/code\u003e 是通过同时打开两个仓库进行的，但是在 augment 中，可以通过上下文机制进行。\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过这种方式可以给新的仓库添加对应的索引，然后在当前仓库的开发中进行使用\u003c/p\u003e\n\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\n\u003cp\u003e另外一个比较好的点是 \u003ccode\u003eaugment\u003c/code\u003e 提供了一些工具配置，可以一键进行安装使用\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image1.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"任务规划\"\u003e任务规划\u003c/h2\u003e\n\u003cp\u003e提供了任务规划，可以让用户手动指定相关任务列表，并且后续能够将本次编辑的任务导出进行保存，后续可以二次进行使用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同理，针对起他通用的agent 任务，augment 也会进行任务拆分，然后逐个实现，只不过这里提供了一个窗口，可以让用户指定任务列表，这针对于用户想要自己创建固定的任务流程是非常有用的\u003c/p\u003e\n\u003ch2 id=\"图表展示\"\u003e图表展示\u003c/h2\u003e\n\u003cp\u003e不知道为什么，感觉 augment 针对 mermaid 的图标进行了展示优化，看起来比较舒服，如果能够再加一个全屏展示会更好\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image3.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"提示词优化\"\u003e提示词优化\u003c/h2\u003e\n\u003cp\u003e可以先编写简短或不完整的提示，然后使用提示增强从代码库中添加相关的参考、结构和约定，以便在发送提示之前对其进行改进。这个非常好用\n\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://genluo.github.io/my-blog/img/image-2.png\"\u003e\u003c/p\u003e","title":"Augment 试用"},{"content":"状态机概述 状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\n核心概念 状态（State）：系统可能处于的一种情况或模式。 事件（Event）：触发状态转换的信号或动作。 转换（Transition）：定义从一个状态到另一个状态的规则。 回调（Callback）：状态转换时执行的逻辑。 应用场景 状态机在以下场景中特别有用：\n游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。 UI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。 工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。 协议实现：网络协议的状态管理（连接中、已连接、断开连接）。 动画控制：管理动画序列和转换。 基本用法 // 定义状态和事件类型 type State = \u0026#39;idle\u0026#39; | \u0026#39;running\u0026#39; | \u0026#39;paused\u0026#39; | \u0026#39;stopped\u0026#39;; type Event = \u0026#39;START\u0026#39; | \u0026#39;PAUSE\u0026#39; | \u0026#39;RESUME\u0026#39; | \u0026#39;STOP\u0026#39;; // 创建状态机实例 const sm = new StateMachine\u0026lt;State, Event\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;PAUSE\u0026#39;, \u0026#39;paused\u0026#39;), t(\u0026#39;paused\u0026#39;, \u0026#39;RESUME\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;), ]); // 触发状态转换 await sm.dispatch(\u0026#39;START\u0026#39;); // idle -\u0026gt; running console.log(sm.getState()); // \u0026#39;running\u0026#39; 高级特性 全局事件（ANY_STATE） 使用 ANY_STATE 符号定义可从任意状态触发的转换：\n// RESET 事件可从任何状态回到 idle 状态 sm.addTransitions([ t(ANY_STATE, \u0026#39;RESET\u0026#39;, \u0026#39;idle\u0026#39;, resetCallback) ]); 状态查询和预测 // 检查当前状态是否可以接收特定事件 if (sm.can(\u0026#39;PAUSE\u0026#39;)) { // 可以执行暂停操作 } // 获取事件触发后的下一个状态 const nextState = sm.getNextState(\u0026#39;STOP\u0026#39;); // \u0026#39;stopped\u0026#39; // 检查当前是否为终止状态（没有可用的出站转换） if (sm.isFinal()) { // 到达终止状态 } 子状态机 子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\n// 创建子状态机 const subMachine = new StateMachine\u0026lt;SubState, SubEvent\u0026gt;(\u0026#39;subIdle\u0026#39;, [ t(\u0026#39;subIdle\u0026#39;, \u0026#39;SUB_START\u0026#39;, \u0026#39;subRunning\u0026#39;), t(\u0026#39;subRunning\u0026#39;, \u0026#39;SUB_STOP\u0026#39;, \u0026#39;subStopped\u0026#39;) ]); // 创建主状态机 const mainMachine = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;START\u0026#39;, \u0026#39;running\u0026#39;), t(\u0026#39;running\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;stopped\u0026#39;) ]); // 将子状态机附加到主状态机的特定状态 mainMachine.addSubStateMachine(\u0026#39;running\u0026#39;, subMachine); 核心设计问题 状态切换回掉的处理 每次派发事件，状态机会立即进行响应，更新新的状态 针对事件切换回调函数执行，不会卡住状态机的状态 极端情况下，存在多个状态回调函数同时在执行的情况 子状态机的生命周期 当主状态机进入子状态时，子状态机被激活 子状态机可以处理自己的事件和状态转换。 当主状态机离开子状态时，子状态机被自动重置（reset） 子状态机只有在父状态机处于激活状态时才能接收事件 实际应用示例 游戏角色控制 graph TD Standing[Standing] --\u0026gt; |WALK| Walking[Walking] Walking --\u0026gt; |STOP| Standing Standing --\u0026gt; |JUMP| Jumping[Jumping] Walking --\u0026gt; |JUMP| Jumping Jumping --\u0026gt; |LAND| Standing Standing --\u0026gt; |ATTACK| Attacking[Attacking] Walking --\u0026gt; |ATTACK| Attacking Jumping --\u0026gt; |ATTACK| Attacking Attacking --\u0026gt; |STOP| Standing type CharacterState = \u0026#39;standing\u0026#39; | \u0026#39;walking\u0026#39; | \u0026#39;jumping\u0026#39; | \u0026#39;attacking\u0026#39;; type CharacterEvent = \u0026#39;WALK\u0026#39; | \u0026#39;JUMP\u0026#39; | \u0026#39;ATTACK\u0026#39; | \u0026#39;STOP\u0026#39; | \u0026#39;LAND\u0026#39;; // 创建角色状态机 const character = new StateMachine\u0026lt;CharacterState, CharacterEvent\u0026gt;(\u0026#39;standing\u0026#39;, [ t(\u0026#39;standing\u0026#39;, \u0026#39;WALK\u0026#39;, \u0026#39;walking\u0026#39;, startWalkAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopWalkAnimation), t(\u0026#39;standing\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;walking\u0026#39;, \u0026#39;JUMP\u0026#39;, \u0026#39;jumping\u0026#39;, startJumpAnimation), t(\u0026#39;jumping\u0026#39;, \u0026#39;LAND\u0026#39;, \u0026#39;standing\u0026#39;, landAnimation), t(ANY_STATE, \u0026#39;ATTACK\u0026#39;, \u0026#39;attacking\u0026#39;, attackAnimation), t(\u0026#39;attacking\u0026#39;, \u0026#39;STOP\u0026#39;, \u0026#39;standing\u0026#39;, stopAttackAnimation), ]); UI 组件状态管理 graph TD Normal[Normal] --\u0026gt; |MOUSE_ENTER| Hover[Hover] Hover --\u0026gt; |MOUSE_LEAVE| Normal Hover --\u0026gt; |MOUSE_DOWN| Pressed[Pressed] Pressed --\u0026gt; |MOUSE_UP| Hover Pressed --\u0026gt; |MOUSE_LEAVE| Normal Normal --\u0026gt; |DISABLE| Disabled[Disabled] Hover --\u0026gt; |DISABLE| Disabled Pressed --\u0026gt; |DISABLE| Disabled Disabled --\u0026gt; |ENABLE| Normal type ButtonState = \u0026#39;normal\u0026#39; | \u0026#39;hover\u0026#39; | \u0026#39;pressed\u0026#39; | \u0026#39;disabled\u0026#39;; type ButtonEvent = \u0026#39;MOUSE_ENTER\u0026#39; | \u0026#39;MOUSE_LEAVE\u0026#39; | \u0026#39;MOUSE_DOWN\u0026#39; | \u0026#39;MOUSE_UP\u0026#39; | \u0026#39;DISABLE\u0026#39; | \u0026#39;ENABLE\u0026#39;; // 创建按钮状态机 const button = new StateMachine\u0026lt;ButtonState, ButtonEvent\u0026gt;(\u0026#39;normal\u0026#39;, [ t(\u0026#39;normal\u0026#39;, \u0026#39;MOUSE_ENTER\u0026#39;, \u0026#39;hover\u0026#39;, showHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeHoverEffect), t(\u0026#39;hover\u0026#39;, \u0026#39;MOUSE_DOWN\u0026#39;, \u0026#39;pressed\u0026#39;, showPressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_UP\u0026#39;, \u0026#39;hover\u0026#39;, removePressedEffect), t(\u0026#39;pressed\u0026#39;, \u0026#39;MOUSE_LEAVE\u0026#39;, \u0026#39;normal\u0026#39;, removeAllEffects), t(ANY_STATE, \u0026#39;DISABLE\u0026#39;, \u0026#39;disabled\u0026#39;, disableButton), t(\u0026#39;disabled\u0026#39;, \u0026#39;ENABLE\u0026#39;, \u0026#39;normal\u0026#39;, enableButton), ]); 游戏角色管理系统 这个例子展示了如何使用嵌套状态机来管理游戏角色的复杂状态。主状态机处理角色的生命周期（闲置、活动、死亡），而子状态机则专注于角色在\u0026quot;活动\u0026quot;状态下可以执行的各种行为\nstateDiagram-v2 [*] --\u0026gt; idle idle --\u0026gt; active: ACTIVATE active --\u0026gt; idle: REST active --\u0026gt; dead: DIE dead --\u0026gt; idle: RESPAWN state active { [*] --\u0026gt; moving moving --\u0026gt; fighting: ENGAGE fighting --\u0026gt; moving: DISENGAGE moving --\u0026gt; interacting: INTERACT interacting --\u0026gt; moving: FINISH } // 主状态机状态和事件 type MainState = \u0026#39;idle\u0026#39; | \u0026#39;active\u0026#39; | \u0026#39;dead\u0026#39;; type MainEvent = \u0026#39;ACTIVATE\u0026#39; | \u0026#39;REST\u0026#39; | \u0026#39;DIE\u0026#39; | \u0026#39;RESPAWN\u0026#39;; // 子状态机状态和事件 type ActiveState = \u0026#39;moving\u0026#39; | \u0026#39;fighting\u0026#39; | \u0026#39;interacting\u0026#39;; type ActiveEvent = \u0026#39;ENGAGE\u0026#39; | \u0026#39;DISENGAGE\u0026#39; | \u0026#39;INTERACT\u0026#39; | \u0026#39;FINISH\u0026#39;; // 创建子状态机（角色活动状态） const activeStateMachine = new StateMachine\u0026lt;ActiveState, ActiveEvent\u0026gt;(\u0026#39;moving\u0026#39;, [ t(\u0026#39;moving\u0026#39;, \u0026#39;ENGAGE\u0026#39;, \u0026#39;fighting\u0026#39;, startCombatSystem), t(\u0026#39;fighting\u0026#39;, \u0026#39;DISENGAGE\u0026#39;, \u0026#39;moving\u0026#39;, endCombatSystem), t(\u0026#39;moving\u0026#39;, \u0026#39;INTERACT\u0026#39;, \u0026#39;interacting\u0026#39;, startInteraction), t(\u0026#39;interacting\u0026#39;, \u0026#39;FINISH\u0026#39;, \u0026#39;moving\u0026#39;, endInteraction) ]); // 创建主状态机（角色生命周期） const characterManager = new StateMachine\u0026lt;MainState, MainEvent\u0026gt;(\u0026#39;idle\u0026#39;, [ t(\u0026#39;idle\u0026#39;, \u0026#39;ACTIVATE\u0026#39;, \u0026#39;active\u0026#39;, activateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;REST\u0026#39;, \u0026#39;idle\u0026#39;, deactivateCharacter), t(\u0026#39;active\u0026#39;, \u0026#39;DIE\u0026#39;, \u0026#39;dead\u0026#39;, handleDeath), t(\u0026#39;dead\u0026#39;, \u0026#39;RESPAWN\u0026#39;, \u0026#39;idle\u0026#39;, handleRespawn) ]); // 将活动状态子状态机附加到主状态机的\u0026#34;active\u0026#34;状态 characterManager.addSubStateMachine(\u0026#39;active\u0026#39;, activeStateMachine); // 使用示例 await characterManager.dispatch(\u0026#39;ACTIVATE\u0026#39;); // 进入active状态，子状态机激活 await activeStateMachine.dispatch(\u0026#39;ENGAGE\u0026#39;); // 切换到战斗状态 await activeStateMachine.dispatch(\u0026#39;DISENGAGE\u0026#39;); // 返回移动状态 await characterManager.dispatch(\u0026#39;REST\u0026#39;); // 回到idle状态，子状态机重置 结合 和UI结合 您的浏览器不支持视频标签。 和AI结合 您的浏览器不支持视频标签。 总结 状态机提供了一种清晰、直观的方式来管理复杂系统的状态转换逻辑。通过明确定义状态、事件和转换规则，可以有效避免状态管理中的混乱和错误。子状态机机制进一步增强了状态机的能力，使其能够处理更复杂的分层状态结构。无论是游戏开发、UI交互还是业务流程管理，状态机都是一种强大而灵活的解决方案。\n","permalink":"https://genluo.github.io/my-blog/posts/statemachine/","summary":"\u003ch2 id=\"状态机概述\"\u003e状态机概述\u003c/h2\u003e\n\u003cp\u003e状态机是一种计算模型，用于描述系统在不同状态之间的转换逻辑。它由状态（States）、事件（Events）和转换（Transitions）组成。状态机在任一时刻只能处于一个特定状态，通过触发事件使其从一个状态转换到另一个状态。\u003c/p\u003e\n\u003ch2 id=\"核心概念\"\u003e核心概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e状态（State）\u003c/strong\u003e：系统可能处于的一种情况或模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e事件（Event）\u003c/strong\u003e：触发状态转换的信号或动作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e转换（Transition）\u003c/strong\u003e：定义从一个状态到另一个状态的规则。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回调（Callback）\u003c/strong\u003e：状态转换时执行的逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"应用场景\"\u003e应用场景\u003c/h2\u003e\n\u003cp\u003e状态机在以下场景中特别有用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e游戏开发：管理游戏角色的不同状态（站立、行走、攻击、受伤等）。\u003c/li\u003e\n\u003cli\u003eUI 交互：控制界面元素在不同状态下的行为（正常、悬停、激活、禁用）。\u003c/li\u003e\n\u003cli\u003e工作流管理：追踪业务流程的不同阶段（创建、审核、发布）。\u003c/li\u003e\n\u003cli\u003e协议实现：网络协议的状态管理（连接中、已连接、断开连接）。\u003c/li\u003e\n\u003cli\u003e动画控制：管理动画序列和转换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本用法\"\u003e基本用法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义状态和事件类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 创建状态机实例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eStateMachine\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003eState\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e\u0026gt;(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;paused\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESUME\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;running\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;stopped\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 触发状态转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003edispatch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;START\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// idle -\u0026gt; running\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetState\u003c/span\u003e());  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;running\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"高级特性\"\u003e高级特性\u003c/h2\u003e\n\u003ch3 id=\"全局事件any_state\"\u003e全局事件（ANY_STATE）\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eANY_STATE\u003c/code\u003e 符号定义可从任意状态触发的转换：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// RESET 事件可从任何状态回到 idle 状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddTransitions\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003et\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eANY_STATE\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;RESET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;idle\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eresetCallback\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"状态查询和预测\"\u003e状态查询和预测\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前状态是否可以接收特定事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecan\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;PAUSE\u0026#39;\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 可以执行暂停操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 获取事件触发后的下一个状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enextState\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetNextState\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;STOP\u0026#39;\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;stopped\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查当前是否为终止状态（没有可用的出站转换）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003esm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eisFinal\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 到达终止状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"子状态机\"\u003e子状态机\u003c/h3\u003e\n\u003cp\u003e子状态机是一种嵌套状态机机制，允许在一个主状态内部有自己的状态转换逻辑。这对于构建复杂的分层状态行为非常有用\u003c/p\u003e","title":"StateMachine"},{"content":"关于我 做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出性能强劲，用户体验优异，能产生业务价值的产品\n常用工具箱 语言：TypeScript、C++ 框架：React、NestJs 运行时：Node.js、Chrome/浏览器、visionOS 标准：webGPU、WebAssembly、 历史项目 淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频） 淘宝3D引擎对应的相关产品 端渲染和云渲染协同切换（webRTC、追帧算法） 引擎Binding技术方案落地（quickJS、wasm） 引擎对应的3D编辑器（编辑器、节点编辑、AI Agent） 专利 一种基于端云协同的三维场景加载及渲染技术（2024-01-12） 全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17） 联系方式 邮箱：isgenluo@gmail.com GitHub：我的GitHub主页 ","permalink":"https://genluo.github.io/my-blog/about/","summary":"\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cp\u003e做过 PC web开发、mobile web开发、 web游戏开发，也尝试过 Apple Vision Pro 上的游戏开发，专注用户交互，梦想是做出\u003cstrong\u003e性能强劲\u003c/strong\u003e，用户\u003cstrong\u003e体验优异\u003c/strong\u003e，能产生业务价值的产品\u003c/p\u003e\n\u003ch3 id=\"常用工具箱\"\u003e常用工具箱\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e语言：TypeScript、C++\u003c/li\u003e\n\u003cli\u003e框架：React、NestJs\u003c/li\u003e\n\u003cli\u003e运行时：Node.js、Chrome/浏览器、visionOS\u003c/li\u003e\n\u003cli\u003e标准：webGPU、WebAssembly、\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"历史项目\"\u003e历史项目\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e淘宝商品创新表达（消费电子行业3D、快消行业序列帧、家装行业全景视频）\u003c/li\u003e\n\u003cli\u003e淘宝3D引擎对应的相关产品\n\u003cul\u003e\n\u003cli\u003e端渲染和云渲染协同切换（webRTC、追帧算法）\u003c/li\u003e\n\u003cli\u003e引擎Binding技术方案落地（quickJS、wasm）\u003c/li\u003e\n\u003cli\u003e引擎对应的3D编辑器（编辑器、节点编辑、AI Agent）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"专利\"\u003e专利\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一种基于端云协同的三维场景加载及渲染技术（2024-01-12）\u003c/li\u003e\n\u003cli\u003e全景视频投放素材生产与展示设计方案（中国 2024-06-11，中国香港2025-01-17）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"联系方式\"\u003e联系方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e邮箱：\u003ca href=\"mailto:isgenluo@gmail.com\"\u003eisgenluo@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGitHub：\u003ca href=\"https://github.com/genluo\"\u003e我的GitHub主页\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"关于我"}]